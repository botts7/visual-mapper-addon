<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="version" content="0.4.0-beta.3.3" data-build="dynamic">
    <title>Flow Management - Visual Mapper</title>
    <link rel="icon" type="image/png" sizes="32x32" href="favicon.png">
    <link rel="icon" type="image/svg+xml" href="favicon.svg">

    <!-- Dynamic CSS loading -->
    <script>
        const cacheKey = sessionStorage.getItem('vmCacheKey') || Date.now();
        sessionStorage.setItem('vmCacheKey', cacheKey);
        document.write('<link rel="stylesheet" href="css/styles.css?v=0.4.0-beta.3.3">');
        document.write('<link rel="stylesheet" href="css/flows.css?v=0.4.0-beta.3.3">');
    </script>
    <noscript>
        <link rel="stylesheet" href="css/styles.css">
        <link rel="stylesheet" href="css/flows.css">
    </noscript>

    <!-- Apply dark mode immediately to prevent flash -->
    <script>
        (function() {
            const theme = localStorage.getItem('visual-mapper-theme');
            if (theme === 'dark' || (!theme && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
                document.documentElement.classList.add('dark-mode');
                document.addEventListener('DOMContentLoaded', () => {
                    document.body.classList.add('dark-mode');
                });
            }
        })();
    </script>
</head>
<body>
    <!-- Navbar injected by js/components/navbar.js -->
    <nav></nav>
    <script type="module" src="js/init.js?v=0.4.0-beta.3.3"></script>

    <div class="flow-container">
        <div class="flow-header">
            <h1>Flow Management</h1>
            <div class="flow-actions">
                <button class="btn btn-primary" onclick="window.location.href='flow-wizard.html'">
                    Create Flow Wizard
                </button>
                <button class="btn btn-secondary" onclick="showTemplatePickerModal()">
                    From Template
                </button>
                <button class="btn btn-secondary" onclick="showBundledFlowsModal()">
                    App Flows
                </button>
                <button class="btn btn-secondary" onclick="showSmartFlowModal()">
                    Smart Flow
                </button>
                <button class="btn btn-secondary" onclick="showImportModal()">
                    Import
                </button>
                <button class="btn btn-secondary" onclick="loadFlows()">
                    Refresh
                </button>
            </div>
        </div>

        <div class="flow-stats" id="flowStats">
            <div class="stat-card">
                <h3>Total Flows</h3>
                <div class="value" id="statTotal">0</div>
            </div>
            <div class="stat-card">
                <h3>Enabled</h3>
                <div class="value" id="statEnabled">0</div>
            </div>
            <div class="stat-card">
                <h3>Queue Depth</h3>
                <div class="value" id="statQueueDepth">0</div>
            </div>
            <div class="stat-card">
                <h3>Success Rate</h3>
                <div class="value" id="statSuccessRate">-</div>
            </div>
        </div>

        <!-- Scheduler Dashboard -->
        <div class="scheduler-dashboard" id="schedulerDashboard">
            <div class="scheduler-header">
                <h3>Scheduler Status</h3>
                <div class="scheduler-controls">
                    <span class="scheduler-status-badge running" id="schedulerStatusBadge">
                        <span class="status-dot running" id="schedulerStatusDot"></span>
                        <span id="schedulerStatusText">Running</span>
                    </span>
                    <label class="auto-refresh-toggle" title="Auto-refresh status every 10 seconds">
                        <input type="checkbox" id="autoRefreshToggle" checked>
                        <span class="toggle-label">Live</span>
                    </label>
                    <button class="btn btn-pause" id="btnPauseScheduler" onclick="pauseScheduler()">
                        Pause All
                    </button>
                    <button class="btn btn-resume" id="btnResumeScheduler" onclick="resumeScheduler()" style="display: none;">
                        Resume
                    </button>
                    <button class="btn btn-clear-queue" id="btnClearQueue" onclick="clearQueue()" title="Clear all queued flows">
                        Clear Queue
                    </button>
                </div>
            </div>

            <div class="device-queue-grid" id="deviceQueueGrid">
                <!-- Device queue cards will be rendered here -->
            </div>
        </div>

        <!-- Alerts Panel -->
        <div class="alerts-panel" id="alertsPanel" style="display: none;">
            <div class="alerts-header">
                <h3>Performance Alerts</h3>
                <button class="btn-clear-alerts" onclick="clearAllAlerts()">Clear All</button>
            </div>
            <div class="alerts-list" id="alertsList">
                <!-- Alerts will be rendered here -->
            </div>
        </div>

        <!-- Disconnected Device Alert -->
        <div id="disconnectedAlert" style="display: none; background: #ff980020; border: 1px solid #FF9800; border-radius: 6px; padding: 15px; margin-bottom: 15px;">
            <div style="display: flex; align-items: flex-start; gap: 10px; flex-wrap: wrap;">
                <span style="font-size: 24px;">‚ö†Ô∏è</span>
                <div style="flex: 1;">
                    <strong style="color: #FF9800;">Some Devices Disconnected</strong>
                    <p style="margin: 5px 0 0 0; color: var(--text-secondary); font-size: 14px;">
                        Flows for disconnected devices cannot be executed. Connect the devices via ADB to run these flows.
                    </p>
                    <div id="disconnectedDevicesList" style="margin-top: 10px;"></div>
                </div>
                <a href="devices.html" class="btn" style="background: #FF9800; color: white; padding: 8px 16px; white-space: nowrap;">
                    Manage Devices
                </a>
            </div>
        </div>

        <div class="flow-filters">
            <select id="flowDeviceFilter">
                <option value="">All Devices</option>
            </select>
            <select id="flowAppFilter">
                <option value="">All Apps</option>
            </select>
            <input type="text" id="flowSearch" placeholder="Search flows...">
            <button class="btn btn-secondary" id="flowFilterReset">Reset</button>
        </div>

        <!-- Flow Table -->
        <div class="flow-table-container">
            <table class="flow-table">
                <thead>
                    <tr>
                        <th>Flow Name</th>
                        <th>App</th>
                        <th>Device</th>
                        <th>IP</th>
                        <th>Steps</th>
                        <th>Schedule</th>
                        <th>Enabled</th>
                        <th>Status</th>
                        <th>Last Executed</th>
                        <th>Success Rate</th>
                        <th>Last Run</th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody id="flowTableBody">
                    <!-- Flow rows will be dynamically inserted here -->
                </tbody>
            </table>
        </div>
    </div>

    <!-- Edit Flow Modal -->
    <div class="modal-overlay" id="editModal">
        <div class="modal-content flow-edit-modal">
            <div class="modal-header">
                <h2>Edit Flow: <span id="editFlowName"></span></h2>
                <button class="btn-close" onclick="closeEditModal()">&times;</button>
            </div>

            <div class="edit-tabs">
                <button class="tab active" id="tabBasic" onclick="switchEditTab('basic', event)">Basic Editor</button>
                <button class="tab" id="tabJSON" onclick="switchEditTab('json', event)">JSON</button>
            </div>

            <div class="modal-body">
                <!-- Basic Editor -->
                <div id="basicEditor">
                    <div class="form-group">
                        <label for="editFlowNameInput">Flow Name</label>
                        <input type="text" id="editFlowNameInput" class="form-control">
                    </div>

                    <div class="form-group">
                        <label for="editTrigger">Trigger</label>
                        <select id="editTrigger" class="form-control">
                            <option value="manual">Manual</option>
                            <option value="periodic">Periodic (Scheduled)</option>
                            <option value="sensor">Sensor Change</option>
                        </select>
                    </div>

                    <div class="form-group">
                        <label for="editUpdateInterval">Update Interval (seconds)</label>
                        <input type="number" id="editUpdateInterval" class="form-control" min="10" value="60">
                    </div>

                    <div class="form-group">
                        <label>Steps</label>
                        <div class="steps-editor" id="stepsEditor">
                            <!-- Steps will be rendered here -->
                        </div>
                        <div class="add-step-buttons" style="display: flex; flex-wrap: wrap; gap: 8px; align-items: center;">
                            <button type="button" class="btn btn-primary btn-sm" onclick="openFlowInWizard()" style="background: #8b5cf6;">
                                ü™Ñ Edit in Wizard
                            </button>
                            <button type="button" class="btn btn-secondary btn-sm" onclick="showInsertSensorDialog()">
                                + Add Sensor
                            </button>
                            <button type="button" class="btn btn-secondary btn-sm" onclick="showInsertActionDialog()">
                                + Add Action
                            </button>
                        </div>
                    </div>
                </div>

                <!-- JSON Editor -->
                <div id="jsonEditor" style="display: none;">
                    <div class="json-editor-toolbar">
                        <div class="json-editor-actions">
                            <button type="button" class="btn btn-secondary btn-sm" onclick="formatFlowJSON()">Format JSON</button>
                            <button type="button" class="btn btn-secondary btn-sm" onclick="validateFlowJSON()">Validate JSON</button>
                            <button type="button" class="btn btn-secondary btn-sm" onclick="copyFlowJSON()">Copy JSON</button>
                        </div>
                        <span id="jsonValidationStatus" class="json-validation-status"></span>
                    </div>
                    <textarea id="editFlowJSON" class="form-control json-editor" rows="20" oninput="queueValidateFlowJSON()"></textarea>
                    <p class="help-text">Edit the raw JSON definition. Changes will sync with the basic editor when you switch tabs.</p>
                </div>
            </div>

            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" onclick="closeEditModal()">Cancel</button>
                <button type="button" class="btn btn-secondary" onclick="saveFlowAsTemplate()">Save as Template</button>
                <button type="button" class="btn btn-primary dev-only" onclick="testCurrentFlow()">Test Flow</button>
                <button type="button" class="btn btn-primary" onclick="saveFlowEdit()">Save Changes</button>
            </div>
        </div>
    </div>

    <!-- Template Picker Modal -->
    <div class="modal-overlay" id="templatePickerModal" style="display: none;">
        <div class="modal-content modal-lg">
            <div class="modal-header">
                <h2>Create Flow from Template</h2>
                <button class="btn-close" onclick="closeTemplatePickerModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="template-picker-container">
                    <!-- Step 1: Select Template -->
                    <div id="templateStep1">
                        <h3>Choose a Template</h3>
                        <div class="template-grid" id="templateGrid">
                            <p class="loading">Loading templates...</p>
                        </div>
                    </div>

                    <!-- Step 2: Configure Flow -->
                    <div id="templateStep2" style="display: none;">
                        <h3>Configure Your Flow</h3>
                        <div class="template-preview" id="templatePreview"></div>

                        <div class="form-group">
                            <label for="templateFlowName">Flow Name</label>
                            <input type="text" id="templateFlowName" class="form-control" placeholder="Enter flow name...">
                        </div>

                        <div class="form-group">
                            <label for="templateDeviceSelect">Target Device</label>
                            <select id="templateDeviceSelect" class="form-control">
                                <option value="">Select a device...</option>
                            </select>
                        </div>

                        <div class="form-group">
                            <label>Template Steps Preview</label>
                            <div class="steps-preview" id="templateStepsPreview"></div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" onclick="closeTemplatePickerModal()">Cancel</button>
                <button type="button" class="btn btn-secondary" id="templateBackBtn" onclick="templateGoBack()" style="display: none;">Back</button>
                <button type="button" class="btn btn-primary" id="templateNextBtn" onclick="templateGoNext()" style="display: none;">Next</button>
                <button type="button" class="btn btn-primary" id="templateCreateBtn" onclick="createFlowFromTemplate()" style="display: none;">Create Flow</button>
            </div>
        </div>
    </div>

    <!-- Save as Template Modal -->
    <div class="modal-overlay" id="saveTemplateModal" style="display: none;">
        <div class="modal-content modal-sm">
            <div class="modal-header">
                <h3>Save Flow as Template</h3>
                <button class="btn-close" onclick="closeSaveTemplateModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="newTemplateName">Template Name</label>
                    <input type="text" id="newTemplateName" class="form-control" placeholder="My Custom Template">
                </div>
                <div class="form-group">
                    <label for="newTemplateTags">Tags (comma-separated)</label>
                    <input type="text" id="newTemplateTags" class="form-control" placeholder="automation, sensor, custom">
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeSaveTemplateModal()">Cancel</button>
                <button class="btn btn-primary" onclick="confirmSaveAsTemplate()">Save Template</button>
            </div>
        </div>
    </div>

    <!-- Import Flow Modal -->
    <div class="modal-overlay" id="importFlowModal" style="display: none;">
        <div class="modal-content modal-lg">
            <div class="modal-header">
                <h2>Import Flows</h2>
                <button class="btn-close" onclick="closeImportModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="importDeviceSelect">Target Device</label>
                    <select id="importDeviceSelect" class="form-control">
                        <option value="">Select target device...</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Import Method</label>
                    <div class="import-methods">
                        <label class="import-method">
                            <input type="radio" name="importMethod" value="file" checked>
                            <span>Upload JSON File</span>
                        </label>
                        <label class="import-method">
                            <input type="radio" name="importMethod" value="paste">
                            <span>Paste JSON</span>
                        </label>
                    </div>
                </div>
                <div id="importFileSection">
                    <div class="form-group">
                        <label for="importFile">Select Export File</label>
                        <input type="file" id="importFile" class="form-control" accept=".json">
                    </div>
                </div>
                <div id="importPasteSection" style="display: none;">
                    <div class="form-group">
                        <label for="importPasteJSON">Paste JSON</label>
                        <textarea id="importPasteJSON" class="form-control" rows="10" placeholder="Paste exported flow JSON here..."></textarea>
                    </div>
                </div>
                <div id="importPreview" style="display: none; margin-top: 15px;">
                    <h4>Import Preview</h4>
                    <div id="importPreviewContent" class="preview-box"></div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeImportModal()">Cancel</button>
                <button class="btn btn-primary" id="confirmImportBtn" onclick="confirmImport()" disabled>Import</button>
            </div>
        </div>
    </div>

    <!-- Bundled App Flows Modal -->
    <div class="modal-overlay" id="bundledFlowsModal" style="display: none;">
        <div class="modal-content modal-lg">
            <div class="modal-header">
                <h2>Pre-Made App Flows</h2>
                <button class="btn-close" onclick="closeBundledFlowsModal()">&times;</button>
            </div>
            <div class="modal-body">
                <p class="modal-description">Install ready-to-use flows for popular apps. Select an app and flow, then choose your target device.</p>
                <div class="form-group">
                    <label for="bundledDeviceSelect">Target Device</label>
                    <select id="bundledDeviceSelect" class="form-control">
                        <option value="">Select target device...</option>
                    </select>
                </div>
                <div class="bundled-flows-grid" id="bundledFlowsGrid">
                    <p class="loading">Loading available app flows...</p>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeBundledFlowsModal()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Smart Flow Generator Modal -->
    <div class="modal-overlay" id="smartFlowModal" style="display: none;">
        <div class="modal-content modal-lg">
            <div class="modal-header">
                <h2>Smart Flow Generator</h2>
                <button class="btn-close" onclick="closeSmartFlowModal()">&times;</button>
            </div>
            <div class="modal-body">
                <p class="modal-description">
                    Generate a flow that automatically visits all known screens in an app and captures data.
                </p>

                <!-- Companion App Status -->
                <div class="companion-status-panel" id="companionStatusPanel" style="display: none;">
                    <div class="status-indicator" id="companionStatusIndicator">
                        <span class="status-dot"></span>
                        <span class="status-text">Checking companion app...</span>
                    </div>
                </div>

                <div class="form-group">
                    <label for="smartFlowDevice">Device</label>
                    <select id="smartFlowDevice" class="form-control" onchange="onSmartFlowDeviceChange()">
                        <option value="">Select device...</option>
                    </select>
                </div>

                <!-- Discovery Mode Selection -->
                <div class="form-group" id="discoveryModeGroup" style="display: none;">
                    <label>Discovery Mode</label>
                    <div class="radio-group">
                        <label class="radio-label">
                            <input type="radio" name="discoveryMode" value="navigation" checked onchange="onDiscoveryModeChange()">
                            <span class="radio-text">Use Navigation Data</span>
                            <span class="radio-desc">Generate flow from previously learned navigation</span>
                        </label>
                        <label class="radio-label" id="liveDiscoveryOption" style="display: none;">
                            <input type="radio" name="discoveryMode" value="live" onchange="onDiscoveryModeChange()">
                            <span class="radio-text">Live Discovery (Android App)</span>
                            <span class="radio-desc">Discover screens and elements in real-time via companion app</span>
                        </label>
                    </div>
                </div>

                <!-- Navigation Data Info Panel -->
                <div class="nav-data-panel" id="navDataPanel" style="display: none;">
                    <div class="nav-data-stats" id="navDataStats"></div>
                </div>

                <div class="form-group" id="appSelectGroup">
                    <label for="smartFlowApp">App (with navigation data)</label>
                    <select id="smartFlowApp" class="form-control" disabled onchange="onSmartFlowAppChange()">
                        <option value="">Select device first...</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Options</label>
                    <div class="checkbox-group">
                        <label class="checkbox-label">
                            <input type="checkbox" id="smartFlowScreenshots" checked>
                            Capture screenshots at each screen
                        </label>
                        <label class="checkbox-label">
                            <input type="checkbox" id="smartFlowSensors" checked>
                            Capture sensors at each screen
                        </label>
                        <label class="checkbox-label" style="margin-top: 8px; padding: 8px; background: #e8f5e9; border-radius: 4px;">
                            <input type="checkbox" id="smartFlowLearnMode">
                            <strong>Learn Mode</strong> - Capture UI elements during test to improve future flows
                            <div style="font-size: 0.8em; color: #666; margin-top: 4px; margin-left: 20px;">
                                Slower but updates navigation data with real screen elements
                            </div>
                        </label>
                    </div>
                </div>
                <div class="smart-flow-preview" id="smartFlowPreview" style="display: none;">
                    <h4>Generated Flow Preview</h4>
                    <div class="preview-warnings" id="smartFlowWarnings" style="display: none;"></div>
                    <div class="preview-stats" id="smartFlowStats"></div>

                    <!-- Tabbed Sections for Sensors/Actions -->
                    <div class="smart-flow-tabs" style="margin: 16px 0;">
                        <div class="tab-buttons" style="display: flex; gap: 0; border-bottom: 2px solid #ddd; flex-wrap: wrap;">
                            <button class="smart-tab-btn active" id="tabSensors" onclick="switchSmartFlowTab('sensors')" style="padding: 10px 16px; border: none; background: #f8f9fa; cursor: pointer; font-weight: 500; border-bottom: 2px solid #2196F3; margin-bottom: -2px; flex: 1; min-width: 140px; position: relative;">
                                <div style="display: flex; flex-direction: column; align-items: center; gap: 2px;">
                                    <span>üìä Existing Sensors</span>
                                    <span style="font-size: 0.75em; color: #888; font-weight: normal;">Will be captured</span>
                                </div>
                                <span id="sensorsTabCount" style="background: #e3f2fd; color: #1976D2; padding: 2px 8px; border-radius: 12px; font-size: 0.8em; position: absolute; top: 4px; right: 4px;">0</span>
                            </button>
                            <button class="smart-tab-btn" id="tabSuggested" onclick="switchSmartFlowTab('suggested')" style="padding: 10px 16px; border: none; background: #fff; cursor: pointer; font-weight: 500; margin-bottom: -2px; flex: 1; min-width: 140px; position: relative;">
                                <div style="display: flex; flex-direction: column; align-items: center; gap: 2px;">
                                    <span>‚ú® Auto-Detected</span>
                                    <span style="font-size: 0.75em; color: #888; font-weight: normal;">New sensors to create</span>
                                </div>
                                <span id="suggestedTabCount" style="background: #fff3cd; color: #856404; padding: 2px 8px; border-radius: 12px; font-size: 0.8em; position: absolute; top: 4px; right: 4px;">0</span>
                            </button>
                            <button class="smart-tab-btn" id="tabActions" onclick="switchSmartFlowTab('actions')" style="padding: 10px 16px; border: none; background: #fff; cursor: pointer; font-weight: 500; margin-bottom: -2px; flex: 1; min-width: 140px; position: relative;">
                                <div style="display: flex; flex-direction: column; align-items: center; gap: 2px;">
                                    <span>üéÆ Flow Steps</span>
                                    <span style="font-size: 0.75em; color: #888; font-weight: normal;">Navigation & actions</span>
                                </div>
                                <span id="actionsTabCount" style="background: #e8f4fd; color: #1565C0; padding: 2px 8px; border-radius: 12px; font-size: 0.8em; position: absolute; top: 4px; right: 4px;">0</span>
                            </button>
                        </div>

                        <!-- Sensors Tab Content -->
                        <div class="smart-tab-content" id="sensorsTabContent" style="padding: 12px; background: #f8f9fa; border-radius: 0 0 8px 8px;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                <span style="font-size: 0.9em; color: #666;">Existing sensors that will be captured</span>
                                <label style="font-size: 0.85em; cursor: pointer;">
                                    <input type="checkbox" id="smartFlowSelectAllSensors" checked onchange="toggleAllSmartFlowSensors(this.checked)"> Select All
                                </label>
                            </div>
                            <div id="smartFlowSensorsList" style="max-height: 220px; overflow-y: auto;"></div>
                        </div>

                        <!-- Suggested Sensors Tab Content -->
                        <div class="smart-tab-content" id="suggestedTabContent" style="padding: 12px; background: #fff8e5; border-radius: 0 0 8px 8px; display: none;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                <span style="font-size: 0.9em; color: #856404;">Smart-detected elements that look like sensor data</span>
                                <label style="font-size: 0.85em; cursor: pointer;">
                                    <input type="checkbox" id="smartFlowSelectAllSuggested" onchange="toggleAllSuggestedSensors(this.checked)"> Select All
                                </label>
                            </div>
                            <div id="suggestedSensorsList" style="max-height: 220px; overflow-y: auto;"></div>
                        </div>

                        <!-- Actions Tab Content -->
                        <div class="smart-tab-content" id="actionsTabContent" style="padding: 12px; background: #e8f4fd; border-radius: 0 0 8px 8px; display: none;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                <span style="font-size: 0.9em; color: #666;">Actions/buttons for Home Assistant</span>
                                <label style="font-size: 0.85em; cursor: pointer;">
                                    <input type="checkbox" id="smartFlowSelectAllActions" checked onchange="toggleAllSmartFlowActions(this.checked)"> Select All
                                </label>
                            </div>
                            <div id="smartFlowActionsList" style="max-height: 220px; overflow-y: auto;"></div>
                        </div>
                    </div>

                    <!-- Steps Section -->
                    <div class="preview-steps-header" style="display: flex; justify-content: space-between; align-items: center; margin: 12px 0 8px 0;">
                        <strong>Steps</strong>
                        <button class="btn btn-sm" id="btnExpandSteps" onclick="toggleSmartFlowSteps()" style="padding: 4px 12px; font-size: 0.85em;">Show All</button>
                    </div>
                    <div class="preview-steps" id="smartFlowSteps" style="max-height: 200px; overflow-y: auto;"></div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeSmartFlowModal()">Cancel</button>
                <button class="btn btn-primary" id="btnGenerateSmartFlow" onclick="generateSmartFlow()" disabled>
                    Generate Flow
                </button>
                <button class="btn btn-warning" id="btnTestSmartFlow" onclick="testSmartFlow()" style="display: none;">
                    üß™ Test Flow
                </button>
                <button class="btn btn-success" id="btnSaveSmartFlow" onclick="saveSmartFlow()" style="display: none;">
                    Save Flow
                </button>
            </div>
        </div>
    </div>

    <!-- Execution Results Modal -->
    <div class="modal-overlay" id="executionResultsModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Execution Results</h2>
                <button class="btn-close" onclick="closeExecutionResultsModal()">&times;</button>
            </div>
            <div class="modal-body" id="executionResultsBody">
                <!-- Results will be dynamically inserted here -->
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" onclick="closeExecutionResultsModal()">Close</button>
            </div>
        </div>
    </div>

    <!-- Insert Sensor Dialog -->
    <div class="modal-overlay" id="insertSensorDialog" style="display: none;">
        <div class="modal-content modal-sm">
            <div class="modal-header">
                <h3>Add Sensor Step</h3>
                <button class="btn-close" onclick="closeInsertSensorDialog()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="sensorSelect">Select Sensor</label>
                    <select id="sensorSelect" class="form-control">
                        <option value="">Loading sensors...</option>
                    </select>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeInsertSensorDialog()">Cancel</button>
                <button class="btn btn-primary" onclick="confirmInsertSensor()">Add Sensor</button>
            </div>
        </div>
    </div>

    <!-- Insert Action Dialog -->
    <div class="modal-overlay" id="insertActionDialog" style="display: none;">
        <div class="modal-content modal-sm">
            <div class="modal-header">
                <h3>Add Action Step</h3>
                <button class="btn-close" onclick="closeInsertActionDialog()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="actionSelect">Select Action</label>
                    <select id="actionSelect" class="form-control">
                        <option value="">Loading actions...</option>
                    </select>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeInsertActionDialog()">Cancel</button>
                <button class="btn btn-primary" onclick="confirmInsertAction()">Add Action</button>
            </div>
        </div>
    </div>

    <!-- Execution Logs Modal -->
    <div class="modal-overlay" id="executionLogsModal" style="display: none;">
        <div class="modal-content modal-lg">
            <div class="modal-header">
                <h2>Execution History: <span id="logsFlowName"></span></h2>
                <button class="btn-close" onclick="closeLogsModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="logs-container" id="logsContainer">
                    <p class="loading">Loading execution history...</p>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" onclick="closeLogsModal()">Close</button>
            </div>
        </div>
    </div>

    <script type="module">
        import FlowManager from './js/modules/flow-manager.js?v=0.0.6.1';

        // Toast notification helper
        function showToast(message, type = 'info') {
            console.log(`[Toast ${type}] ${message}`);
            // Simple toast - could be enhanced
            const toast = document.createElement('div');
            toast.className = `toast toast-${type}`;
            toast.textContent = message;
            document.body.appendChild(toast);
            setTimeout(() => toast.remove(), 3000);
        }

        // Initialize FlowManager
        window.flowManager = new FlowManager();
        window.showToast = showToast;

        // Detect dev mode (localhost or port 3000)
        const isDevMode = window.location.hostname === 'localhost' ||
                          window.location.hostname === '127.0.0.1' ||
                          window.location.port === '3000';
        window.isDevMode = isDevMode;

        if (isDevMode) {
            console.log('[Flows] Dev Mode Enabled - Test buttons visible');
            document.body.classList.add('dev-mode');
        }

        let flows = [];
        const runningFlows = new Set(); // Track currently executing flows
        const deviceInfoMap = new Map(); // Map device_id to device info (model, etc.)
        const connectedDeviceIds = new Set(); // Track connected device IDs
        let deviceIdentityMap = {}; // For reconnection info

        // Check if a device is connected
        function isDeviceConnected(deviceId) {
            // Direct match (connection ID)
            if (connectedDeviceIds.has(deviceId)) return true;

            // Check via identity map (stable device ID -> current_connection)
            const identityInfo = deviceIdentityMap[deviceId];
            if (identityInfo && identityInfo.current_connection) {
                if (connectedDeviceIds.has(identityInfo.current_connection)) return true;
            }

            return false;
        }

        // Load device identity info for reconnection
        async function loadDeviceIdentities() {
            try {
                const response = await fetch(`${window.flowManager.apiBase}/adb/known-devices`);
                if (!response.ok) throw new Error('Failed to fetch known devices');
                const data = await response.json();
                const devices = data.devices || [];
                deviceIdentityMap = {};
                devices.forEach(device => {
                    deviceIdentityMap[device.stable_device_id] = device;
                });
            } catch (error) {
                console.warn('[Flows] Could not load device identities:', error);
            }
        }

        // Reconnect a device
        window.reconnectDevice = async function(connectionId) {
            const ipMatch = connectionId.match(/^(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}):(\d+)$/);
            if (!ipMatch) {
                alert('Cannot auto-reconnect. Please go to Devices page to connect manually.');
                return;
            }

            const btn = event.target;
            const originalText = btn.textContent;
            btn.disabled = true;
            btn.textContent = 'Connecting...';

            try {
                const response = await fetch(`${window.flowManager.apiBase}/adb/connect`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ host: ipMatch[1], port: parseInt(ipMatch[2]) })
                });
                if (!response.ok) throw new Error('Connection failed');
                btn.textContent = 'Connected!';
                btn.style.background = '#4CAF50';
                // Reload flows after successful reconnection
                setTimeout(() => loadFlows(), 500);
            } catch (error) {
                btn.textContent = 'Failed';
                btn.style.background = '#f44336';
                setTimeout(() => {
                    btn.disabled = false;
                    btn.textContent = originalText;
                    btn.style.background = '';
                }, 2000);
            }
        };

        // Update disconnected alert visibility
        function updateDisconnectedAlert() {
            const alert = document.getElementById('disconnectedAlert');
            const disconnectedList = document.getElementById('disconnectedDevicesList');

            // Get unique disconnected device IDs from flows
            const disconnectedDeviceIds = new Set();
            flows.forEach(flow => {
                if (!isDeviceConnected(flow.device_id)) {
                    disconnectedDeviceIds.add(flow.device_id);
                }
            });

            if (disconnectedDeviceIds.size === 0) {
                alert.style.display = 'none';
                return;
            }

            alert.style.display = 'block';

            // Build list of disconnected devices with reconnect buttons
            let html = '';
            for (const deviceId of disconnectedDeviceIds) {
                const identityInfo = deviceIdentityMap[deviceId] || {};
                const lastConnection = identityInfo.current_connection || null;
                const model = identityInfo.model || deviceId;
                const hasReconnectable = lastConnection && /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}:\d+$/.test(lastConnection);

                html += `
                    <div style="display: inline-flex; align-items: center; gap: 8px; margin: 4px 8px 4px 0; padding: 4px 8px; background: var(--background-color); border-radius: 4px;">
                        <span style="font-size: 13px;"><strong>${model}</strong></span>
                        ${hasReconnectable ? `
                            <button onclick="window.reconnectDevice('${lastConnection}')" class="btn btn-sm" style="padding: 2px 8px; font-size: 11px; background: #4CAF50;">
                                Reconnect
                            </button>
                        ` : ''}
                    </div>
                `;
            }
            disconnectedList.innerHTML = html;
        }

        async function loadDeviceInfo() {
            try {
                const response = await fetch(`${window.flowManager.apiBase}/adb/devices`);
                if (!response.ok) throw new Error('Failed to fetch devices');
                const data = await response.json();
                const devices = data.devices || [];

                deviceInfoMap.clear();
                connectedDeviceIds.clear();
                devices.forEach(device => {
                    deviceInfoMap.set(device.id, device);
                    connectedDeviceIds.add(device.id); // Track connected device IDs
                });
                console.log(`[Flows] Loaded info for ${devices.length} connected devices`);
            } catch (error) {
                console.warn('[Flows] Could not load device info:', error);
            }
        }

        async function loadFlows() {
            try {
                // Load device info first (for device names)
                await loadDeviceInfo();
                flows = await window.flowManager.getFlows();
                updateFlowFilters();
                renderFlowTable();
                updateStats();
                updateDisconnectedAlert(); // Show alert if devices are disconnected
                await loadAlerts(); // Load alerts after flows
                await loadSchedulerStatus(); // Load scheduler status
                await loadFlowExecutionStatuses(); // Load execution history for each flow
            } catch (error) {
                console.error('Failed to load flows:', error);
                showToast('Failed to load flows: ' + error.message, 'error');
            }
        }

        async function loadFlowExecutionStatuses() {
            // Fetch latest execution status for each flow
            for (const flow of flows) {
                fetchFlowExecutionStatus(flow.device_id, flow.flow_id);
            }
        }

        async function fetchFlowExecutionStatus(deviceId, flowId) {
            try {
                const response = await fetch(`${window.flowManager.apiBase}/flows/${deviceId}/${flowId}/latest`);
                if (!response.ok) {
                    throw new Error('Failed to fetch execution status');
                }

                const data = await response.json();
                updateFlowStatus(flowId, data);
            } catch (error) {
                console.warn(`[Flows] Could not load execution status for ${flowId}:`, error);
                // Update to show error state
                const statusCell = document.getElementById(`last-run-status-${flowId.replace(/[^a-zA-Z0-9]/g, '_')}`);
                if (statusCell) {
                    statusCell.innerHTML = '<span class="status-error" title="Could not load status">‚ö†Ô∏è Error</span>';
                }
            }
        }

        function updateFlowStatus(flowId, executionData) {
            const safeFlowId = flowId.replace(/[^a-zA-Z0-9]/g, '_');
            const statusCell = document.getElementById(`last-run-status-${safeFlowId}`);

            if (!statusCell) {
                console.warn(`[Flows] Status cell not found for flow ${flowId}`);
                return;
            }

            if (!executionData) {
                // No execution history yet
                statusCell.innerHTML = '<span class="status-none" title="Never executed">‚Äî</span>';
                return;
            }

            const { success, error, started_at, duration_ms, executed_steps, total_steps } = executionData;

            // Format timestamp
            const timeAgo = formatTimeAgo(started_at);

            // Create status HTML
            let statusHTML = '';
            if (success) {
                const title = `Success - ${timeAgo}\n${executed_steps}/${total_steps} steps completed in ${duration_ms}ms`;
                statusHTML = `<span class="status-success" title="${escapeHtml(title)}">‚úÖ Success</span>`;
            } else {
                const errorMsg = error || 'Unknown error';
                const title = `Failed - ${timeAgo}\n${executed_steps}/${total_steps} steps completed\nError: ${errorMsg}`;
                statusHTML = `<span class="status-failed" title="${escapeHtml(title)}">‚ùå Failed</span>`;
            }

            statusCell.innerHTML = statusHTML;
        }

        async function viewFlowLogs(deviceId, flowId, flowName) {
            try {
                // Update modal title
                const title = document.getElementById('logsFlowName');
                if (title) title.textContent = flowName;

                // Show loading state
                const content = document.getElementById('logsContainer');
                if (!content) {
                    console.error('[Flows] logsContainer element not found');
                    return;
                }
                content.innerHTML = '<p style="text-align: center; padding: 40px;">Loading execution history...</p>';

                // Show modal
                const modal = document.getElementById('executionLogsModal');
                if (modal) modal.style.display = 'flex';

                // Fetch execution history
                const response = await fetch(`${window.flowManager.apiBase}/flows/${deviceId}/${flowId}/history?limit=20`);
                if (!response.ok) {
                    throw new Error('Failed to fetch execution history');
                }

                const data = await response.json();
                const history = data.history || [];

                // Render execution history
                if (history.length === 0) {
                    content.innerHTML = '<p style="text-align: center; padding: 40px; color: var(--text-secondary);">No execution history found. This flow has not been executed yet.</p>';
                    return;
                }

                // Build HTML for execution history
                let historyHTML = '<div style="display: flex; flex-direction: column; gap: 16px;">';

                for (const execution of history.reverse()) {
                    const statusIcon = execution.success ? '‚úÖ' : '‚ùå';
                    const statusClass = execution.success ? 'success' : 'failed';
                    // Apply UTC fix for timestamp parsing
                    let startedAtStr = execution.started_at;
                    if (startedAtStr && !startedAtStr.endsWith('Z') && !startedAtStr.includes('+') && !startedAtStr.includes('-', 10)) {
                        startedAtStr += 'Z';
                    }
                    const startedAt = new Date(startedAtStr);
                    const timeAgo = formatTimeAgo(execution.started_at);
                    const formattedDate = startedAt.toLocaleString();

                    historyHTML += `
                        <div class="execution-log-card" style="border: 1px solid var(--border-color); border-radius: 8px; padding: 16px; background: var(--card-bg);">
                            <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 12px;">
                                <div>
                                    <div style="font-weight: 600; margin-bottom: 4px;">
                                        ${statusIcon} ${execution.success ? 'Success' : 'Failed'}
                                    </div>
                                    <div style="font-size: 0.875rem; color: var(--text-secondary);">
                                        ${formattedDate} (${timeAgo})
                                    </div>
                                </div>
                                <div style="text-align: right; font-size: 0.875rem; color: var(--text-secondary);">
                                    <div>${execution.executed_steps}/${execution.total_steps} steps</div>
                                    <div>${execution.duration_ms}ms</div>
                                </div>
                            </div>
                    `;

                    // Show error if failed
                    if (!execution.success && execution.error) {
                        historyHTML += `
                            <div style="padding: 8px 12px; background: rgba(239, 68, 68, 0.1); border-left: 3px solid #ef4444; border-radius: 4px; margin-bottom: 12px;">
                                <strong style="color: #ef4444;">Error:</strong> ${escapeHtml(execution.error)}
                            </div>
                        `;
                    }

                    // Show step details
                    if (execution.steps && execution.steps.length > 0) {
                        historyHTML += '<div style="margin-top: 12px;"><strong>Steps:</strong></div>';
                        historyHTML += '<div style="display: flex; flex-direction: column; gap: 8px; margin-top: 8px;">';

                        for (const step of execution.steps) {
                            const stepIcon = step.success ? '‚úì' : '‚úó';
                            const stepClass = step.success ? 'success' : 'failed';
                            const stepColor = step.success ? '#22c55e' : '#ef4444';

                            historyHTML += `
                                <div style="display: flex; gap: 8px; padding: 8px; background: var(--bg-secondary); border-radius: 4px; font-size: 0.875rem;">
                                    <span style="color: ${stepColor}; font-weight: bold;">${stepIcon}</span>
                                    <div style="flex: 1;">
                                        <div><strong>${step.step_type}</strong></div>
                                        ${step.description ? `<div style="color: var(--text-secondary);">${escapeHtml(step.description)}</div>` : ''}
                                        ${!step.success && step.error ? `<div style="color: #ef4444; margin-top: 4px;">${escapeHtml(step.error)}</div>` : ''}
                                    </div>
                                    ${step.duration_ms !== null ? `<div style="color: var(--text-secondary); white-space: nowrap;">${step.duration_ms}ms</div>` : ''}
                                </div>
                            `;
                        }

                        historyHTML += '</div>';
                    }

                    historyHTML += '</div>';
                }

                historyHTML += '</div>';

                content.innerHTML = historyHTML;

            } catch (error) {
                console.error('Failed to load execution logs:', error);
                const content = document.getElementById('logsContainer');
                if (content) {
                    content.innerHTML = `
                        <p style="text-align: center; padding: 40px; color: #ef4444;">
                            Failed to load execution history: ${escapeHtml(error.message)}
                        </p>
                    `;
                }
            }
        }

        function closeLogsModal() {
            const modal = document.getElementById('executionLogsModal');
            if (modal) modal.style.display = 'none';
        }

        // Make functions globally accessible for onclick handlers
        window.viewFlowLogs = viewFlowLogs;
        window.closeLogsModal = closeLogsModal;

        async function loadSchedulerStatus() {
            try {
                const response = await fetch(`${window.flowManager.apiBase}/scheduler/status`);
                if (!response.ok) throw new Error('Failed to fetch scheduler status');

                const data = await response.json();
                const status = data.status;

                renderSchedulerStatus(status);
            } catch (error) {
                console.error('Failed to load scheduler status:', error);
                const deviceGrid = document.getElementById('deviceQueueGrid');
                if (deviceGrid) {
                    deviceGrid.innerHTML = `
                        <p style="color: var(--text-secondary); grid-column: 1 / -1; text-align: center;">
                            Unable to load scheduler status
                        </p>
                    `;
                }
            }
        }

        function renderSchedulerStatus(status) {
            const statusBadge = document.getElementById('schedulerStatusBadge');
            const statusDot = document.getElementById('schedulerStatusDot');
            const statusText = document.getElementById('schedulerStatusText');
            const pauseBtn = document.getElementById('btnPauseScheduler');
            const resumeBtn = document.getElementById('btnResumeScheduler');
            const deviceQueues = document.getElementById('deviceQueueGrid');

            // Update status badge
            let state = 'stopped';
            if (status.running && !status.paused) {
                state = 'running';
                if (statusText) statusText.textContent = 'Running';
            } else if (status.paused) {
                state = 'paused';
                if (statusText) statusText.textContent = 'Paused';
            } else {
                if (statusText) statusText.textContent = 'Stopped';
            }

            if (statusBadge) statusBadge.className = `scheduler-status-badge ${state}`;
            if (statusDot) statusDot.className = `status-dot ${state}`;

            // Toggle buttons
            if (pauseBtn && resumeBtn) {
                if (status.paused) {
                    pauseBtn.style.display = 'none';
                    resumeBtn.style.display = 'inline-block';
                } else {
                    pauseBtn.style.display = 'inline-block';
                    resumeBtn.style.display = 'none';
                }
            }

            // Render device queue cards
            if (!deviceQueues) return;

            const devices = status.devices || {};
            const deviceIds = Object.keys(devices);

            if (deviceIds.length === 0) {
                deviceQueues.innerHTML = `
                    <p style="color: var(--text-secondary); grid-column: 1 / -1; text-align: center;">
                        No devices with active schedulers
                    </p>
                `;
                return;
            }

            deviceQueues.innerHTML = deviceIds.map(deviceId => {
                const device = devices[deviceId];
                const queueDepth = device.queue_depth || 0;
                const queueClass = queueDepth > 5 ? 'critical' : (queueDepth > 2 ? 'warning' : '');

                return `
                    <div class="device-queue-card">
                        <h4>
                            <span style="width: 8px; height: 8px; border-radius: 50%; background: ${device.scheduler_active ? '#22c55e' : '#94a3b8'};"></span>
                            ${escapeHtml(deviceId)}
                        </h4>
                        <div class="queue-stats">
                            <div class="queue-stat">
                                <span class="queue-stat-label">Queue</span>
                                <span class="queue-stat-value ${queueClass}">${queueDepth}</span>
                            </div>
                            <div class="queue-stat">
                                <span class="queue-stat-label">Total Runs</span>
                                <span class="queue-stat-value">${device.total_executions || 0}</span>
                            </div>
                            <div class="queue-stat">
                                <span class="queue-stat-label">Last Run</span>
                                <span class="queue-stat-value" style="font-size: 12px;">
                                    ${device.last_execution ? formatTimeAgo(device.last_execution) : 'Never'}
                                </span>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function formatTimeAgo(dateStr) {
            if (!dateStr) return 'Never';
            // Backend sends UTC timestamps without 'Z' suffix - add it if missing
            let isoStr = dateStr;
            if (!dateStr.endsWith('Z') && !dateStr.includes('+') && !dateStr.includes('-', 10)) {
                isoStr = dateStr + 'Z';
            }
            const date = new Date(isoStr);
            const now = new Date();
            const diffMs = now - date;
            const diffSec = Math.floor(diffMs / 1000);
            const diffMin = Math.floor(diffSec / 60);
            const diffHour = Math.floor(diffMin / 60);

            if (diffSec < 60) return `${diffSec}s ago`;
            if (diffMin < 60) return `${diffMin}m ago`;
            if (diffHour < 24) return `${diffHour}h ago`;
            return date.toLocaleDateString();
        }

        async function pauseScheduler() {
            try {
                const response = await fetch(`${window.flowManager.apiBase}/scheduler/pause`, {
                    method: 'POST'
                });

                if (!response.ok) throw new Error('Failed to pause scheduler');

                showToast('Scheduler paused', 'success');
                await loadSchedulerStatus();
            } catch (error) {
                showToast('Failed to pause scheduler: ' + error.message, 'error');
            }
        }

        async function resumeScheduler() {
            try {
                const response = await fetch(`${window.flowManager.apiBase}/scheduler/resume`, {
                    method: 'POST'
                });

                if (!response.ok) throw new Error('Failed to resume scheduler');

                showToast('Scheduler resumed', 'success');
                await loadSchedulerStatus();
            } catch (error) {
                showToast('Failed to resume scheduler: ' + error.message, 'error');
            }
        }

        async function clearQueue() {
            try {
                const response = await fetch(`${window.flowManager.apiBase}/scheduler/clear-queue`, {
                    method: 'POST'
                });

                if (!response.ok) throw new Error('Failed to clear queue');

                const result = await response.json();
                showToast(result.message || 'Queue cleared', 'success');
                await loadSchedulerStatus();
            } catch (error) {
                showToast('Failed to clear queue: ' + error.message, 'error');
            }
        }

        async function loadAlerts() {
            try {
                const response = await fetch(`${window.flowManager.apiBase}/flows/alerts?limit=10`);
                if (!response.ok) throw new Error('Failed to fetch alerts');

                const data = await response.json();
                const alerts = data.alerts || [];

                renderAlerts(alerts);
            } catch (error) {
                console.error('Failed to load alerts:', error);
            }
        }

        function renderAlerts(alerts) {
            const alertsPanel = document.getElementById('alertsPanel');
            const alertsList = document.getElementById('alertsList');

            if (alerts.length === 0) {
                alertsPanel.classList.add('hidden');
                return;
            }

            alertsPanel.classList.remove('hidden');

            alertsList.innerHTML = alerts.map(alert => `
                <div class="alert-card severity-${alert.severity}">
                    <div class="alert-content">
                        <div class="alert-message">
                            ${getSeverityIcon(alert.severity)} ${escapeHtml(alert.message)}
                        </div>
                        <div class="alert-timestamp">
                            ${formatDateTime(alert.timestamp)}
                            ${alert.device_id ? ` ‚Ä¢ Device: ${alert.device_id}` : ''}
                            ${alert.flow_id ? ` ‚Ä¢ Flow: ${alert.flow_id}` : ''}
                        </div>
                        ${alert.recommendations && alert.recommendations.length > 0 ? `
                            <ul class="alert-recommendations">
                                ${alert.recommendations.map(rec => `<li>${escapeHtml(rec)}</li>`).join('')}
                            </ul>
                        ` : ''}
                    </div>
                    <button type="button" class="alert-dismiss" onclick="dismissAlert('${alert.device_id}', event)" title="Dismiss alert">
                        √ó
                    </button>
                </div>
            `).join('');
        }

        function getSeverityIcon(severity) {
            const icons = {
                info: '‚ÑπÔ∏è',
                warning: '‚ö†Ô∏è',
                error: '‚ùå',
                critical: 'üö®'
            };
            return icons[severity] || '‚ÑπÔ∏è';
        }

        async function clearAllAlerts() {
            if (!confirm('Clear all performance alerts?')) {
                return;
            }

            try {
                const response = await fetch(`${window.flowManager.apiBase}/flows/alerts`, {
                    method: 'DELETE'
                });

                if (!response.ok) throw new Error('Failed to clear alerts');

                showToast('Alerts cleared', 'success');
                await loadAlerts();
            } catch (error) {
                showToast('Failed to clear alerts: ' + error.message, 'error');
            }
        }

        async function dismissAlert(deviceId, event) {
            event.stopPropagation();

            try {
                const url = deviceId
                    ? `${window.flowManager.apiBase}/flows/alerts?device_id=${encodeURIComponent(deviceId)}`
                    : `${window.flowManager.apiBase}/flows/alerts`;

                const response = await fetch(url, {
                    method: 'DELETE'
                });

                if (!response.ok) throw new Error('Failed to dismiss alert');

                await loadAlerts();
            } catch (error) {
                showToast('Failed to dismiss alert: ' + error.message, 'error');
            }
        }

        function updateFlowFilters() {
            const deviceSelect = document.getElementById('flowDeviceFilter');
            const appSelect = document.getElementById('flowAppFilter');
            if (!deviceSelect || !appSelect) {
                return;
            }

            const currentDevice = deviceSelect.value;
            const currentApp = appSelect.value;

            const deviceCounts = new Map();
            const appCounts = new Map();

            flows.forEach(flow => {
                deviceCounts.set(flow.device_id, (deviceCounts.get(flow.device_id) || 0) + 1);
                const apps = getFlowApps(flow);
                if (!apps.length) {
                    appCounts.set('__unknown__', (appCounts.get('__unknown__') || 0) + 1);
                } else {
                    apps.forEach(app => appCounts.set(app, (appCounts.get(app) || 0) + 1));
                }
            });

            deviceSelect.innerHTML = '<option value="">All Devices</option>';
            Array.from(deviceCounts.entries()).sort((a, b) => a[0].localeCompare(b[0])).forEach(([deviceId, count]) => {
                const option = document.createElement('option');
                option.value = deviceId;
                const { deviceName } = parseDeviceId(deviceId);
                option.textContent = `${deviceName} (${count})`;
                deviceSelect.appendChild(option);
            });

            appSelect.innerHTML = '<option value="">All Apps</option>';
            Array.from(appCounts.entries()).sort((a, b) => a[0].localeCompare(b[0])).forEach(([app, count]) => {
                const option = document.createElement('option');
                option.value = app;
                const label = app === '__unknown__' ? 'Unknown' : app;
                option.textContent = `${label} (${count})`;
                appSelect.appendChild(option);
            });

            if (currentDevice && Array.from(deviceSelect.options).some(opt => opt.value === currentDevice)) {
                deviceSelect.value = currentDevice;
            }
            if (currentApp && Array.from(appSelect.options).some(opt => opt.value === currentApp)) {
                appSelect.value = currentApp;
            }
        }

        function applyFlowFilters(flowList) {
            const deviceValue = document.getElementById('flowDeviceFilter')?.value || '';
            const appValue = document.getElementById('flowAppFilter')?.value || '';
            const searchValue = document.getElementById('flowSearch')?.value?.toLowerCase() || '';

            let filtered = flowList;
            if (deviceValue) {
                filtered = filtered.filter(flow => flow.device_id === deviceValue);
            }
            if (appValue) {
                filtered = filtered.filter(flow => {
                    const apps = getFlowApps(flow);
                    if (!apps.length) {
                        return appValue === '__unknown__';
                    }
                    return apps.includes(appValue);
                });
            }
            if (searchValue) {
                filtered = filtered.filter(flow => {
                    const apps = getFlowApps(flow);
                    const appText = apps.join(' ').toLowerCase();
                    return (
                        (flow.name || '').toLowerCase().includes(searchValue) ||
                        (flow.flow_id || '').toLowerCase().includes(searchValue) ||
                        (flow.device_id || '').toLowerCase().includes(searchValue) ||
                        appText.includes(searchValue)
                    );
                });
            }
            return filtered;
        }

        function renderFlowTable() {
            const tbody = document.getElementById('flowTableBody');
            const filteredFlows = applyFlowFilters(flows);

            if (flows.length === 0) {
                tbody.innerHTML = `
                    <tr>
                        <td colspan="11" class="empty-state">
                            <p>No flows configured yet.</p>
                            <p>Flows will appear here once you create them via the API.</p>
                        </td>
                    </tr>
                `;
                return;
            }

            if (filteredFlows.length === 0) {
                tbody.innerHTML = `
                    <tr>
                        <td colspan="11" class="empty-state">
                            <p>No flows match the current filters.</p>
                            <p>Try clearing the filters or adjusting your search.</p>
                        </td>
                    </tr>
                `;
                return;
            }

            tbody.innerHTML = filteredFlows.map(flow => {
                const flowKey = `${flow.device_id}:${flow.flow_id}`;
                const isRunning = runningFlows.has(flowKey);
                const isConnected = isDeviceConnected(flow.device_id);

                // Extract apps from launch_app steps
                const apps = getFlowApps(flow);
                const appsDisplay = apps.length > 0 ? apps.join(', ') : '-';

                // Parse device ID into name and IP
                const { deviceName, deviceIP } = parseDeviceId(flow.device_id);

                // Connection status badge
                const connectionBadge = isConnected
                    ? '<span style="background: #4CAF50; color: white; padding: 1px 6px; border-radius: 3px; font-size: 10px; margin-left: 5px;">Online</span>'
                    : '<span style="background: #f44336; color: white; padding: 1px 6px; border-radius: 3px; font-size: 10px; margin-left: 5px;">Offline</span>';

                return `
                <tr style="${!isConnected ? 'opacity: 0.7; background: #f4433610;' : ''}">
                    <td><strong>${escapeHtml(flow.name)}</strong></td>
                    <td><code style="font-size: 11px;">${escapeHtml(appsDisplay)}</code></td>
                    <td>${escapeHtml(deviceName)}${connectionBadge}</td>
                    <td><code>${escapeHtml(deviceIP)}</code></td>
                    <td>${flow.steps.length} steps</td>
                    <td>${formatSchedule(flow.update_interval_seconds)}</td>
                    <td>
                        <label class="toggle-switch">
                            <input type="checkbox"
                                   ${flow.enabled ? 'checked' : ''}
                                   onchange="toggleFlowEnabled('${flow.device_id}', '${flow.flow_id}', this.checked)">
                            <span class="toggle-slider"></span>
                        </label>
                    </td>
                    <td>
                        <span class="flow-status ${isRunning ? 'running' : (flow.enabled ? 'enabled' : 'disabled')}">
                            ${isRunning ? '‚ñ∂ Running' : (flow.enabled ? 'Enabled' : 'Disabled')}
                        </span>
                    </td>
                    <td>${formatDateTime(flow.last_executed)}</td>
                    <td>${formatSuccessRate(flow)}</td>
                    <td id="last-run-status-${flow.flow_id.replace(/[^a-zA-Z0-9]/g, '_')}">
                        <span class="status-loading">‚è≥ Loading...</span>
                    </td>
                    <td>
                        <div class="flow-row-actions">
                            <button id="execute-btn-${flow.flow_id.replace(/[^a-zA-Z0-9]/g, '_')}"
                                    class="btn-icon execute ${isRunning ? 'running' : ''} ${!isConnected ? 'offline' : ''}"
                                    data-device-id="${flow.device_id}"
                                    data-flow-id="${flow.flow_id}"
                                    onclick="executeFlow('${flow.device_id}', '${flow.flow_id}')"
                                    title="${isConnected ? 'Execute Now' : 'Device Offline - Cannot Execute'}"
                                    ${isRunning || !isConnected ? 'disabled' : ''}
                                    style="${!isConnected ? 'opacity: 0.5; cursor: not-allowed;' : ''}">
                                ${isRunning ? '‚è≥' : (!isConnected ? '‚è∏' : '‚ñ∂')}
                            </button>
                            <button class="btn-icon logs"
                                    onclick="viewFlowLogs('${flow.device_id}', '${flow.flow_id}', '${escapeHtml(flow.name)}')"
                                    title="View Execution Logs">
                                üìã
                            </button>
                            <button class="btn-icon test dev-only"
                                    onclick="testFlow('${flow.device_id}', '${flow.flow_id}')"
                                    title="${isConnected ? 'Test Flow (Dev Mode Only)' : 'Device Offline - Cannot Test'}"
                                    ${isRunning || !isConnected ? 'disabled' : ''}
                                    style="${!isConnected ? 'opacity: 0.5; cursor: not-allowed;' : ''}">
                                üß™
                            </button>
                            <button class="btn-icon export"
                                    onclick="exportFlow('${flow.device_id}', '${flow.flow_id}')"
                                    title="Export Flow">
                                üì§
                            </button>
                            <button class="btn-icon edit"
                                    onclick="editFlow('${flow.device_id}', '${flow.flow_id}')"
                                    title="Edit">
                                ‚úè
                            </button>
                            <button class="btn-icon delete"
                                    onclick="deleteFlow('${flow.device_id}', '${flow.flow_id}', '${escapeHtml(flow.name)}')"
                                    title="Delete">
                                ‚úï
                            </button>
                        </div>
                    </td>
                </tr>
            `;
            }).join('');
        }

        async function updateStats() {
            const totalFlows = flows.length;
            const enabledFlows = flows.filter(f => f.enabled).length;

            document.getElementById('statTotal').textContent = totalFlows;
            document.getElementById('statEnabled').textContent = enabledFlows;

            // Get metrics for queue depth and success rate
            try {
                const metricsData = await window.flowManager.getMetrics();
                const metrics = metricsData.all_devices || {};

                let totalQueueDepth = 0;
                let totalSuccessRate = 0;
                let deviceCount = 0;

                Object.values(metrics).forEach(m => {
                    if (m.queue_depth !== undefined) {
                        totalQueueDepth += m.queue_depth;
                        deviceCount++;
                    }
                    if (m.success_rate !== undefined) {
                        totalSuccessRate += m.success_rate;
                    }
                });

                document.getElementById('statQueueDepth').textContent = totalQueueDepth;

                if (deviceCount > 0) {
                    const avgSuccessRate = (totalSuccessRate / deviceCount) * 100;
                    document.getElementById('statSuccessRate').textContent =
                        avgSuccessRate.toFixed(1) + '%';
                } else {
                    document.getElementById('statSuccessRate').textContent = '-';
                }
            } catch (error) {
                console.error('Failed to load metrics:', error);
            }
        }

        async function executeFlow(deviceId, flowId) {
            const flowKey = `${deviceId}:${flowId}`;
            const safeFlowId = flowId.replace(/[^a-zA-Z0-9]/g, '_');
            const executeBtn = document.getElementById(`execute-btn-${safeFlowId}`);

            // Prevent double-execution
            if (runningFlows.has(flowKey)) {
                showToast('Flow is already running', 'warning');
                return;
            }

            try {
                // Add to running set and update only this button's UI
                runningFlows.add(flowKey);
                if (executeBtn) {
                    executeBtn.classList.add('running');
                    executeBtn.disabled = true;
                    executeBtn.innerHTML = '‚è≥';
                }

                showToast('Flow execution started...', 'info');

                // Execute the flow via API and get execution result
                const response = await fetch(`${window.flowManager.apiBase}/flows/${deviceId}/${flowId}/execute`, {
                    method: 'POST'
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.detail || 'Flow execution failed');
                }

                const result = await response.json();
                console.log('[Flows] Flow execution result:', result);

                // Show execution results
                showExecutionResults(result);

                // Show success or failure toast
                if (result.success) {
                    showToast('Flow execution completed!', 'success');
                } else {
                    showToast('Flow execution failed: ' + (result.error_message || 'Unknown error'), 'error');
                }

                // Update the last run status for this flow immediately
                fetchFlowExecutionStatus(deviceId, flowId);

                // Keep running state visible for 1 second, then reset button
                setTimeout(async () => {
                    runningFlows.delete(flowKey);
                    if (executeBtn) {
                        executeBtn.classList.remove('running');
                        executeBtn.disabled = false;
                        executeBtn.innerHTML = '‚ñ∂';
                    }
                    await loadFlows(); // Reload to get updated stats
                }, 1000);

            } catch (error) {
                // Remove from running set on error and reset button
                runningFlows.delete(flowKey);
                if (executeBtn) {
                    executeBtn.classList.remove('running');
                    executeBtn.disabled = false;
                    executeBtn.innerHTML = '‚ñ∂';
                }
                showToast('Failed to execute flow: ' + error.message, 'error');
            }
        }

        /**
         * Show execution results in modal with step-by-step details
         * @param {Object} result - Execution result from API
         * @param {Object} flowDefinition - Optional flow definition (for Smart Flow tests)
         */
        function showExecutionResults(result, flowDefinition = null) {
            const modal = document.getElementById('executionResultsModal');
            const content = document.getElementById('executionResultsBody');

            // Guard against missing elements
            if (!modal || !content) {
                console.warn('[Flows] Execution results modal elements not found');
                return;
            }

            // Get flow definition - use provided definition or find in flows array
            const flow = flowDefinition || flows.find(f => f.flow_id === result.flow_id);
            const totalSteps = flow ? flow.steps.length : result.executed_steps ?? 0;
            const executedSteps = result.executed_steps ?? 0;
            const executionTime = result.execution_time_ms ?? 0;
            const capturedSensors = result.captured_sensors || {};

            // Build step-by-step breakdown with values
            const stepResults = result.step_results || [];
            let stepsHtml = '';
            if (flow && flow.steps && flow.steps.length > 0) {
                stepsHtml = `
                    <div class="execution-steps">
                        <h5>Execution Steps:</h5>
                        <ol class="step-list">
                            ${flow.steps.map((step, index) => {
                                let statusIcon = '';
                                let statusClass = '';
                                let errorDetail = '';
                                let stepDetails = '';

                                // Find step result for this index
                                const stepResult = stepResults.find(sr => sr.step_index === index);

                                if (index < executedSteps) {
                                    // Step was executed successfully
                                    statusIcon = '‚úÖ';
                                    statusClass = 'step-success';

                                    // Add details for capture_sensors steps
                                    if (stepResult && stepResult.details && stepResult.details.sensors) {
                                        const sensors = stepResult.details.sensors;
                                        const sensorCount = Object.keys(sensors).length;
                                        if (sensorCount > 0) {
                                            stepDetails = `<div class="step-details" style="margin-top: 8px; padding: 8px; background: var(--preview-background); border-radius: 4px; font-size: 0.9em;">
                                                <strong>Captured ${sensorCount} sensor${sensorCount !== 1 ? 's' : ''}:</strong>
                                                <ul style="margin: 4px 0 0 0; padding-left: 20px;">
                                                    ${Object.entries(sensors).map(([id, info]) =>
                                                        `<li><strong>${escapeHtml(info.name || id)}:</strong> <span style="color: var(--primary-color);">${escapeHtml(String(info.value ?? '--'))}</span></li>`
                                                    ).join('')}
                                                </ul>
                                            </div>`;
                                        }
                                    }

                                    // Add details for execute_action steps
                                    if (stepResult && stepResult.details && stepResult.details.action_id) {
                                        stepDetails = `<div class="step-details" style="margin-top: 8px; padding: 8px; background: var(--preview-background); border-radius: 4px; font-size: 0.9em;">
                                            <strong>Action:</strong> ${escapeHtml(stepResult.details.action_id)}
                                            <span style="color: #4CAF50; margin-left: 8px;">${escapeHtml(stepResult.details.action_result || 'executed')}</span>
                                        </div>`;
                                    }
                                } else if (result.failed_step !== null && result.failed_step !== undefined && index === result.failed_step) {
                                    // Step failed
                                    statusIcon = '‚ùå';
                                    statusClass = 'step-failed';
                                    errorDetail = `<div class="step-error">${escapeHtml(result.error_message || 'Unknown error')}</div>`;
                                } else {
                                    // Step was skipped
                                    statusIcon = '‚è≠Ô∏è';
                                    statusClass = 'step-skipped';
                                }

                                const stepDesc = step.description || `${step.step_type} step`;

                                return `
                                    <li class="step-item ${statusClass}">
                                        <span class="step-status">${statusIcon}</span>
                                        <span class="step-info">
                                            <strong>${escapeHtml(stepDesc)}</strong>
                                            <span class="step-type">(${escapeHtml(step.step_type)})</span>
                                        </span>
                                        ${errorDetail}
                                        ${stepDetails}
                                    </li>
                                `;
                            }).join('')}
                        </ol>
                    </div>
                `;
            }

            // Display results based on success/failure
            if (result.success) {
                content.innerHTML = `
                    <div class="test-success">
                        <h4>‚úÖ Flow Execution Successful</h4>
                        <div class="execution-summary">
                            <p><strong>Executed Steps:</strong> ${executedSteps} / ${totalSteps}</p>
                            <p><strong>Execution Time:</strong> ${executionTime}ms</p>
                        </div>
                        ${stepsHtml}
                        ${Object.keys(capturedSensors).length > 0 ? `
                            <div class="captured-sensors" style="margin-top: 16px; padding: 12px; background: #e8f5e9; border-radius: 8px; border-left: 4px solid #4CAF50;">
                                <h5 style="margin: 0 0 8px 0; color: #2e7d32;">üìä Captured Sensor Values:</h5>
                                <ul style="margin: 0; padding-left: 20px;">
                                    ${Object.entries(capturedSensors).map(([id, value]) =>
                                        `<li style="margin: 4px 0;"><strong>${escapeHtml(id)}:</strong> <span style="color: #1565c0; font-weight: 600;">${escapeHtml(String(value))}</span></li>`
                                    ).join('')}
                                </ul>
                            </div>
                        ` : '<div style="margin-top: 16px; padding: 12px; background: #fff3e0; border-radius: 8px; border-left: 4px solid #ff9800;"><strong>‚ö†Ô∏è No sensor values captured.</strong> Check if sensors exist and screen was correct.</div>'}
                        ${result.learned_screens && result.learned_screens.length > 0 ? `
                            <div class="learned-screens" style="margin-top: 16px; padding: 12px; background: #e3f2fd; border-radius: 8px; border-left: 4px solid #2196F3;">
                                <h5 style="margin: 0 0 8px 0; color: #1565c0;">üéì Learn Mode - Captured ${result.learned_screens.length} Screen(s):</h5>
                                <ul style="margin: 0; padding-left: 20px; font-size: 0.9em;">
                                    ${result.learned_screens.map(screen =>
                                        `<li style="margin: 4px 0;">
                                            <strong>${escapeHtml(screen.activity?.split('.')?.pop() || 'Unknown')}</strong>
                                            <span style="color: #666;"> - ${screen.element_count} elements (${screen.clickable_count} clickable)</span>
                                        </li>`
                                    ).join('')}
                                </ul>
                                <p style="margin: 8px 0 0 0; font-size: 0.85em; color: #666;">Navigation graph updated for future Smart Flows!</p>
                            </div>
                        ` : ''}
                    </div>
                `;
            } else {
                const failedStepNum = result.failed_step !== null && result.failed_step !== undefined ? result.failed_step + 1 : 'Unknown';

                content.innerHTML = `
                    <div class="test-failure">
                        <h4>‚ùå Flow Execution Failed</h4>
                        <div class="execution-summary">
                            <p><strong>Failed at Step:</strong> ${failedStepNum}</p>
                            <p><strong>Error:</strong> ${escapeHtml(result.error_message || 'Unknown error')}</p>
                            <p><strong>Executed Steps:</strong> ${executedSteps} / ${totalSteps}</p>
                        </div>
                        ${stepsHtml}
                    </div>
                `;
            }

            // Show modal
            modal.classList.add('active');
        }

        /**
         * Close execution results modal
         */
        function closeExecutionResultsModal() {
            const modal = document.getElementById('executionResultsModal');
            modal.classList.remove('active');
        }

        // Make function globally accessible for onclick handlers
        window.closeExecutionResultsModal = closeExecutionResultsModal;

        /**
         * Test a flow from the flow table
         */
        async function testFlow(deviceId, flowId) {
            try {
                showToast('Testing flow...', 'info');

                // Execute the flow via API
                const response = await fetch(`${window.flowManager.apiBase}/flows/${deviceId}/${flowId}/execute`, {
                    method: 'POST'
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.detail || 'Flow test failed');
                }

                const result = await response.json();
                console.log('[Flows] Flow test result:', result);

                // Show execution results
                showExecutionResults(result);

                if (result.success) {
                    showToast('Flow test passed!', 'success');
                } else {
                    showToast('Flow test failed', 'error');
                }

            } catch (error) {
                console.error('[Flows] Flow test error:', error);
                showToast(`Test error: ${error.message}`, 'error');
            }
        }

        /**
         * Test the currently edited flow (from edit modal)
         */
        async function testCurrentFlow() {
            if (!editingFlow) {
                showToast('No flow is being edited', 'error');
                return;
            }

            try {
                showToast('Testing flow...', 'info');

                const { deviceId, flowId } = editingFlow;

                // Get the current flow data from the form (in case user made changes)
                // We'll test the saved version, not the in-progress edits
                const response = await fetch(`${window.flowManager.apiBase}/flows/${deviceId}/${flowId}/execute`, {
                    method: 'POST'
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.detail || 'Flow test failed');
                }

                const result = await response.json();
                console.log('[Flows] Flow test result:', result);

                // Show execution results
                showExecutionResults(result);

                if (result.success) {
                    showToast('Flow test passed!', 'success');
                } else {
                    showToast('Flow test failed', 'error');
                }

            } catch (error) {
                console.error('[Flows] Flow test error:', error);
                showToast(`Test error: ${error.message}`, 'error');
            }
        }

        async function deleteFlow(deviceId, flowId, flowName) {
            if (!confirm(`Are you sure you want to delete flow "${flowName}"?`)) {
                return;
            }

            try {
                await window.flowManager.deleteFlow(deviceId, flowId);
                showToast('Flow deleted successfully', 'success');
                await loadFlows();
            } catch (error) {
                showToast('Failed to delete flow: ' + error.message, 'error');
            }
        }

        function formatDateTime(dateStr) {
            if (!dateStr) return 'Never';
            // Backend sends UTC timestamps without 'Z' suffix - add it if missing
            let isoStr = dateStr;
            if (!dateStr.endsWith('Z') && !dateStr.includes('+') && !dateStr.includes('-', 10)) {
                isoStr = dateStr + 'Z';
            }
            const date = new Date(isoStr);
            return date.toLocaleString();
        }

        function formatSuccessRate(flow) {
            if (flow.execution_count === 0) return '-';
            const rate = (flow.success_count / flow.execution_count) * 100;
            return `${flow.success_count}/${flow.execution_count} (${rate.toFixed(0)}%)`;
        }

        /**
         * Format schedule interval for display
         * Shows "Manual" badge for manual-only flows, formatted time for scheduled
         */
        function formatSchedule(seconds) {
            if (!seconds || seconds === 0) {
                return '<span class="schedule-badge manual" title="Manual trigger only - no automatic scheduling">Manual</span>';
            }

            let display;
            if (seconds < 60) {
                display = `${seconds}s`;
            } else if (seconds < 3600) {
                const mins = Math.floor(seconds / 60);
                display = `${mins}m`;
            } else if (seconds < 86400) {
                const hours = Math.floor(seconds / 3600);
                const mins = Math.floor((seconds % 3600) / 60);
                display = mins > 0 ? `${hours}h ${mins}m` : `${hours}h`;
            } else {
                const days = Math.floor(seconds / 86400);
                display = `${days}d`;
            }

            return `<span class="schedule-badge scheduled" title="Runs every ${display}">${display}</span>`;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        /**
         * Extract app package names from flow steps
         */
        function getFlowApps(flow) {
            const apps = new Set();
            for (const step of flow.steps || []) {
                if (step.step_type === 'launch_app' && step.package) {
                    // Get the short app name (last part of package)
                    const parts = step.package.split('.');
                    const shortName = parts[parts.length - 1] || step.package;
                    apps.add(shortName);
                }
            }
            return Array.from(apps);
        }

        /**
         * Parse device ID into device name and IP address
         * Format: IP:PORT or just device name
         */
        function parseDeviceId(deviceId) {
            if (!deviceId) {
                return { deviceName: '-', deviceIP: '-' };
            }

            // Try to get device info from the map
            const deviceInfo = deviceInfoMap.get(deviceId);

            // Check if it looks like IP:PORT format
            const ipPortMatch = deviceId.match(/^(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}):?(\d+)?$/);
            if (ipPortMatch) {
                const ip = ipPortMatch[1];
                const port = ipPortMatch[2] || '5555';
                // Use device model if available, otherwise IP
                return {
                    deviceName: deviceInfo?.model || ip,
                    deviceIP: `${ip}:${port}`
                };
            }

            // If it's not IP format, treat the whole thing as device name
            return {
                deviceName: deviceInfo?.model || deviceId,
                deviceIP: '-'
            };
        }

        let editingFlow = null;
        let currentEditTab = 'basic';

        function switchEditTab(tabName, ev) {
            currentEditTab = tabName;

            const tabBasic = document.getElementById('tabBasic');
            const tabJSON = document.getElementById('tabJSON');
            const basicEditor = document.getElementById('basicEditor');
            const jsonEditorPanel = document.getElementById('jsonEditor');

            if (tabBasic) tabBasic.classList.remove('active');
            if (tabJSON) tabJSON.classList.remove('active');

            if (tabName === 'json') {
                if (tabJSON) tabJSON.classList.add('active');
                if (basicEditor) basicEditor.style.display = 'none';
                if (jsonEditorPanel) jsonEditorPanel.style.display = 'block';
                syncJSONFromBasicForm();
                return;
            }

            if (!syncBasicFormFromJSON()) {
                currentEditTab = 'json';
                if (tabJSON) tabJSON.classList.add('active');
                if (basicEditor) basicEditor.style.display = 'none';
                if (jsonEditorPanel) jsonEditorPanel.style.display = 'block';
                return;
            }

            if (tabBasic) tabBasic.classList.add('active');
            if (basicEditor) basicEditor.style.display = 'block';
            if (jsonEditorPanel) jsonEditorPanel.style.display = 'none';
        }

        async function toggleFlowEnabled(deviceId, flowId, enabled) {
            try {
                const flow = flows.find(f => f.device_id === deviceId && f.flow_id === flowId);
                if (!flow) return;

                // Update flow with new enabled status
                const updatedFlow = { ...flow, enabled };
                await window.flowManager.updateFlow(deviceId, flowId, updatedFlow);

                showToast(`Flow ${enabled ? 'enabled' : 'disabled'}`, 'success');
                await loadFlows(); // Reload to update UI
            } catch (error) {
                showToast(`Failed to toggle flow: ${error.message}`, 'error');
                // Reload to revert checkbox state
                await loadFlows();
            }
        }

        function renderFlowSteps() {
            if (!editingFlow) return;

            const stepsContainer = document.getElementById('stepsEditor');
            const steps = editingFlow.flow.steps || [];

            if (steps.length === 0) {
                stepsContainer.innerHTML = '<p style="text-align:center;color:#64748b;">No steps defined yet. Click "+ Add Step" to create one.</p>';
                return;
            }

            stepsContainer.innerHTML = steps.map((step, index) => `
                <div class="step-card" data-step-index="${index}">
                    <div class="step-card-header">
                        <span class="step-type-badge">${step.step_type || 'unknown'}</span>
                        <div class="step-actions">
                            <button type="button" class="step-action-btn" onclick="moveStepUp(${index})" ${index === 0 ? 'disabled' : ''}>‚Üë</button>
                            <button type="button" class="step-action-btn" onclick="moveStepDown(${index})" ${index === steps.length - 1 ? 'disabled' : ''}>‚Üì</button>
                            <button type="button" class="step-action-btn" onclick="deleteStep(${index})">‚úï</button>
                        </div>
                    </div>
                    <div class="step-fields">
                        ${renderStepFields(step, index)}
                    </div>
                </div>
            `).join('');
        }

        function renderStepFields(step, index) {
            const stepType = step.step_type;
            let fields = `
                <div class="step-field" style="grid-column: 1 / -1">
                    <label>Description</label>
                    <input type="text" value="${escapeHtml(step.description || '')}"
                           onchange="updateStepField(${index}, 'description', this.value)">
                </div>
            `;

            // Type-specific fields
            if (stepType === 'tap') {
                fields += `
                    <div class="step-field">
                        <label>X Coordinate</label>
                        <input type="number" value="${step.x || ''}"
                               onchange="updateStepField(${index}, 'x', parseInt(this.value))">
                    </div>
                    <div class="step-field">
                        <label>Y Coordinate</label>
                        <input type="number" value="${step.y || ''}"
                               onchange="updateStepField(${index}, 'y', parseInt(this.value))">
                    </div>
                `;
            } else if (stepType === 'swipe') {
                fields += `
                    <div class="step-field">
                        <label>Start X</label>
                        <input type="number" value="${step.start_x || ''}"
                               onchange="updateStepField(${index}, 'start_x', parseInt(this.value))">
                    </div>
                    <div class="step-field">
                        <label>Start Y</label>
                        <input type="number" value="${step.start_y || ''}"
                               onchange="updateStepField(${index}, 'start_y', parseInt(this.value))">
                    </div>
                    <div class="step-field">
                        <label>End X</label>
                        <input type="number" value="${step.end_x || ''}"
                               onchange="updateStepField(${index}, 'end_x', parseInt(this.value))">
                    </div>
                    <div class="step-field">
                        <label>End Y</label>
                        <input type="number" value="${step.end_y || ''}"
                               onchange="updateStepField(${index}, 'end_y', parseInt(this.value))">
                    </div>
                    <div class="step-field">
                        <label>Duration (ms)</label>
                        <input type="number" value="${step.duration || 500}"
                               onchange="updateStepField(${index}, 'duration', parseInt(this.value))">
                    </div>
                `;
            } else if (stepType === 'type_text') {
                fields += `
                    <div class="step-field" style="grid-column: 1 / -1">
                        <label>Text to Type</label>
                        <input type="text" value="${escapeHtml(step.text || '')}"
                               onchange="updateStepField(${index}, 'text', this.value)">
                    </div>
                `;
            } else if (stepType === 'wait') {
                fields += `
                    <div class="step-field">
                        <label>Duration (seconds)</label>
                        <input type="number" step="0.1" value="${step.duration || 1}"
                               onchange="updateStepField(${index}, 'duration', parseFloat(this.value))">
                    </div>
                `;
            } else if (stepType === 'launch_app') {
                fields += `
                    <div class="step-field" style="grid-column: 1 / -1">
                        <label>Package Name</label>
                        <input type="text" value="${escapeHtml(step.package || '')}"
                               onchange="updateStepField(${index}, 'package', this.value)">
                    </div>
                `;
            } else if (stepType === 'capture_sensors') {
                fields += `
                    <div class="step-field" style="grid-column: 1 / -1">
                        <label>Sensor IDs (comma-separated)</label>
                        <input type="text" value="${(step.sensor_ids || []).join(', ')}"
                               onchange="updateStepField(${index}, 'sensor_ids', this.value.split(',').map(s => s.trim()).filter(s => s))">
                    </div>
                `;
            }

            return fields;
        }

        function updateStepField(stepIndex, field, value) {
            if (!editingFlow) return;
            editingFlow.flow.steps[stepIndex][field] = value;
        }

        function deleteStep(stepIndex) {
            if (!editingFlow) return;
            if (!confirm('Delete this step?')) return;

            editingFlow.flow.steps.splice(stepIndex, 1);
            renderFlowSteps();
        }

        function moveStepUp(stepIndex) {
            if (!editingFlow || stepIndex === 0) return;
            const steps = editingFlow.flow.steps;
            [steps[stepIndex - 1], steps[stepIndex]] = [steps[stepIndex], steps[stepIndex - 1]];
            renderFlowSteps();
        }

        function moveStepDown(stepIndex) {
            if (!editingFlow) return;
            const steps = editingFlow.flow.steps;
            if (stepIndex === steps.length - 1) return;
            [steps[stepIndex], steps[stepIndex + 1]] = [steps[stepIndex + 1], steps[stepIndex]];
            renderFlowSteps();
        }

        function addNewStep() {
            if (!editingFlow) return;

            const stepType = prompt('Enter step type (tap, swipe, type_text, wait, launch_app, capture_sensors, keypress):');
            if (!stepType) return;

            const newStep = {
                step_type: stepType,
                description: `New ${stepType} step`,
                retry_on_failure: false,
                max_retries: 3
            };

            // Initialize type-specific fields
            if (stepType === 'tap') {
                newStep.x = 0;
                newStep.y = 0;
            } else if (stepType === 'swipe') {
                newStep.start_x = 0;
                newStep.start_y = 0;
                newStep.end_x = 0;
                newStep.end_y = 0;
                newStep.duration = 500;
            } else if (stepType === 'type_text') {
                newStep.text = '';
            } else if (stepType === 'wait') {
                newStep.duration = 1;
            } else if (stepType === 'launch_app') {
                newStep.package = '';
            } else if (stepType === 'capture_sensors') {
                newStep.sensor_ids = [];
            }

            editingFlow.flow.steps.push(newStep);
            renderFlowSteps();
        }

        /**
         * Open current flow in the Visual Wizard for visual editing
         */
        function openFlowInWizard() {
            if (!editingFlow) {
                showToast('No flow selected', 'error');
                return;
            }

            const { deviceId, flowId } = editingFlow;

            // Close the edit modal
            closeEditModal();

            // Navigate to wizard with flow edit params
            const wizardUrl = `flow-wizard.html?editFlow=true&device=${encodeURIComponent(deviceId)}&flow=${encodeURIComponent(flowId)}`;
            window.location.href = wizardUrl;
        }
        window.openFlowInWizard = openFlowInWizard;

        async function showInsertSensorDialog() {
            if (!editingFlow) return;

            try {
                // Fetch existing sensors for this device
                const response = await fetch(`/api/sensors/${encodeURIComponent(editingFlow.deviceId)}`);
                const data = await response.json();
                const sensors = data.sensors || [];

                if (sensors.length === 0) {
                    showToast('No sensors found for this device', 'warning');
                    return;
                }

                // Create dialog overlay
                const overlay = document.createElement('div');
                overlay.id = 'insert-sensor-overlay';
                overlay.style.cssText = `
                    position: fixed; top: 0; left: 0; right: 0; bottom: 0;
                    background: rgba(0, 0, 0, 0.7); z-index: 10001;
                    display: flex; align-items: center; justify-content: center;
                `;

                const dialog = document.createElement('div');
                dialog.style.cssText = `
                    background: var(--card-background, #1e1e1e); border-radius: 8px;
                    padding: 20px; max-width: 500px; width: 90%; max-height: 70vh;
                    overflow-y: auto; color: var(--text-color, #e0e0e0);
                `;

                dialog.innerHTML = `
                    <h3 style="margin: 0 0 15px 0;">üìä Insert Existing Sensor</h3>
                    <p style="margin-bottom: 15px; color: #888; font-size: 0.9em;">
                        Select a sensor to add to this flow. Smart detection will find the element at runtime.
                    </p>
                    <div id="sensorList" style="max-height: 400px; overflow-y: auto;">
                        ${sensors.map(s => {
                            const resourceId = s.source?.element_resource_id ? s.source.element_resource_id.split('/').pop() : null;
                            const elementText = s.source?.element_text || null;
                            // Extract app name from resource_id (e.g., "com.byd.bydautolink:id/tem_tv" -> "bydautolink")
                            const appPackage = s.source?.element_resource_id ? s.source.element_resource_id.split(':')[0].split('.').pop() : null;
                            const extractionMethod = s.extraction_rule?.method || 'exact';
                            const deviceClass = s.device_class && s.device_class !== 'none' ? s.device_class : null;
                            const currentValue = s.current_value;
                            const unit = s.unit_of_measurement || '';
                            // Apply UTC fix for timestamp parsing
                            let updatedAtStr = s.updated_at;
                            if (updatedAtStr && !updatedAtStr.endsWith('Z') && !updatedAtStr.includes('+') && !updatedAtStr.includes('-', 10)) {
                                updatedAtStr += 'Z';
                            }
                            const lastUpdated = updatedAtStr ? new Date(updatedAtStr).toLocaleString() : null;

                            return `
                            <div class="sensor-option" data-sensor-id="${s.sensor_id}" data-sensor-name="${s.friendly_name}" style="
                                padding: 12px; margin: 5px 0; background: rgba(255,255,255,0.05);
                                border-radius: 6px; cursor: pointer; border: 2px solid transparent;
                            ">
                                <div style="display: flex; justify-content: space-between; align-items: center;">
                                    <span style="font-weight: bold; font-size: 1.05em;">${s.friendly_name}</span>
                                    ${currentValue !== null && currentValue !== undefined ?
                                        '<span style="background: #4CAF50; color: white; padding: 2px 8px; border-radius: 10px; font-size: 0.85em; font-weight: 600;">' + currentValue + unit + '</span>' :
                                        '<span style="background: #666; color: #ccc; padding: 2px 8px; border-radius: 10px; font-size: 0.8em;">No value</span>'
                                    }
                                </div>
                                <div style="display: flex; gap: 8px; flex-wrap: wrap; margin-top: 6px;">
                                    ${appPackage ? '<span style="background: rgba(33,150,243,0.2); color: #64B5F6; padding: 2px 6px; border-radius: 4px; font-size: 0.75em;">üì± ' + appPackage + '</span>' : ''}
                                    ${deviceClass ? '<span style="background: rgba(156,39,176,0.2); color: #CE93D8; padding: 2px 6px; border-radius: 4px; font-size: 0.75em;">üìä ' + deviceClass + '</span>' : ''}
                                    ${extractionMethod ? '<span style="background: rgba(255,152,0,0.2); color: #FFB74D; padding: 2px 6px; border-radius: 4px; font-size: 0.75em;">üîß ' + extractionMethod + '</span>' : ''}
                                </div>
                                <div style="font-size: 0.8em; color: #888; margin-top: 6px;">
                                    ${resourceId ? '<div>üÜî <code style="background: rgba(0,0,0,0.3); padding: 1px 4px; border-radius: 3px;">' + resourceId + '</code></div>' : ''}
                                    ${elementText ? '<div style="margin-top: 2px;">üìù "' + (elementText.length > 40 ? elementText.substring(0, 40) + '...' : elementText) + '"</div>' : ''}
                                </div>
                                ${lastUpdated ? '<div style="font-size: 0.7em; color: #666; margin-top: 4px;">‚è±Ô∏è Last: ' + lastUpdated + '</div>' : ''}
                            </div>
                        `;}).join('')}
                    </div>
                    <div style="display: flex; gap: 10px; margin-top: 15px; justify-content: flex-end;">
                        <button type="button" class="btn btn-secondary" id="cancelBtn">Cancel</button>
                    </div>
                `;

                overlay.appendChild(dialog);
                document.body.appendChild(overlay);

                // Handle sensor selection
                dialog.querySelectorAll('.sensor-option').forEach(option => {
                    option.addEventListener('mouseover', () => option.style.borderColor = '#4CAF50');
                    option.addEventListener('mouseout', () => option.style.borderColor = 'transparent');
                    option.addEventListener('click', () => {
                        const sensorId = option.dataset.sensorId;
                        const sensorName = option.dataset.sensorName;

                        // Add capture_sensors step
                        editingFlow.flow.steps.push({
                            step_type: 'capture_sensors',
                            sensor_ids: [sensorId],
                            description: `Capture: ${sensorName}`
                        });

                        renderFlowSteps();
                        document.body.removeChild(overlay);
                        showToast(`Added sensor: ${sensorName}`, 'success');
                    });
                });

                dialog.querySelector('#cancelBtn').addEventListener('click', () => {
                    document.body.removeChild(overlay);
                });

                overlay.addEventListener('click', (e) => {
                    if (e.target === overlay) document.body.removeChild(overlay);
                });

            } catch (error) {
                console.error('Failed to load sensors:', error);
                showToast('Failed to load sensors', 'error');
            }
        }

        async function showInsertActionDialog() {
            if (!editingFlow) return;

            try {
                // Fetch existing actions for this device
                const response = await fetch(`/api/actions/${encodeURIComponent(editingFlow.deviceId)}`);
                const data = await response.json();
                const actions = data.actions || [];

                if (actions.length === 0) {
                    showToast('No actions found for this device', 'warning');
                    return;
                }

                // Create dialog overlay
                const overlay = document.createElement('div');
                overlay.id = 'insert-action-overlay';
                overlay.style.cssText = `
                    position: fixed; top: 0; left: 0; right: 0; bottom: 0;
                    background: rgba(0, 0, 0, 0.7); z-index: 10001;
                    display: flex; align-items: center; justify-content: center;
                `;

                const dialog = document.createElement('div');
                dialog.style.cssText = `
                    background: var(--card-background, #1e1e1e); border-radius: 8px;
                    padding: 20px; max-width: 500px; width: 90%; max-height: 70vh;
                    overflow-y: auto; color: var(--text-color, #e0e0e0);
                `;

                dialog.innerHTML = `
                    <h3 style="margin: 0 0 15px 0;">‚ö° Insert Existing Action</h3>
                    <p style="margin-bottom: 15px; color: #888; font-size: 0.9em;">
                        Select an action to add to this flow.
                    </p>
                    <div id="actionList" style="max-height: 300px; overflow-y: auto;">
                        ${actions.map(a => `
                            <div class="action-option" data-action-id="${a.id}" data-action-name="${a.action?.name || 'Action'}" style="
                                padding: 12px; margin: 5px 0; background: rgba(255,255,255,0.05);
                                border-radius: 6px; cursor: pointer; border: 2px solid transparent;
                            ">
                                <div style="font-weight: bold;">${a.action?.name || 'Unnamed Action'}</div>
                                <div style="font-size: 0.85em; color: #888; margin-top: 4px;">
                                    Type: ${a.action?.action_type || 'unknown'}
                                    ${a.action?.actions ? ` ‚Ä¢ ${a.action.actions.length} steps` : ''}
                                </div>
                            </div>
                        `).join('')}
                    </div>
                    <div style="display: flex; gap: 10px; margin-top: 15px; justify-content: flex-end;">
                        <button type="button" class="btn btn-secondary" id="cancelBtn">Cancel</button>
                    </div>
                `;

                overlay.appendChild(dialog);
                document.body.appendChild(overlay);

                // Handle action selection
                dialog.querySelectorAll('.action-option').forEach(option => {
                    option.addEventListener('mouseover', () => option.style.borderColor = '#2196F3');
                    option.addEventListener('mouseout', () => option.style.borderColor = 'transparent');
                    option.addEventListener('click', () => {
                        const actionId = option.dataset.actionId;
                        const actionName = option.dataset.actionName;

                        // Add execute_action step
                        editingFlow.flow.steps.push({
                            step_type: 'execute_action',
                            action_id: actionId,
                            description: `Execute: ${actionName}`
                        });

                        renderFlowSteps();
                        document.body.removeChild(overlay);
                        showToast(`Added action: ${actionName}`, 'success');
                    });
                });

                dialog.querySelector('#cancelBtn').addEventListener('click', () => {
                    document.body.removeChild(overlay);
                });

                overlay.addEventListener('click', (e) => {
                    if (e.target === overlay) document.body.removeChild(overlay);
                });

            } catch (error) {
                console.error('Failed to load actions:', error);
                showToast('Failed to load actions', 'error');
            }
        }

        function syncJSONFromBasicForm() {
            if (!editingFlow) return;

            // Build updated flow object from basic form (use only existing elements)
            const nameInput = document.getElementById('editFlowNameInput');
            const intervalInput = document.getElementById('editUpdateInterval');

            const updatedFlow = {
                ...editingFlow.flow
            };

            if (nameInput) updatedFlow.name = nameInput.value;
            if (intervalInput) updatedFlow.update_interval_seconds = parseInt(intervalInput.value);

            // Update JSON editor
            const jsonEditor = document.getElementById('editFlowJSON');
            if (jsonEditor) jsonEditor.value = JSON.stringify(updatedFlow, null, 2);
            setJsonValidationStatus(true, 'Synced from basic editor');
        }

        function syncBasicFormFromJSON() {
            if (!editingFlow) return;

            try {
                const jsonEditor = document.getElementById('editFlowJSON');
                if (!jsonEditor) return;

                const flowData = JSON.parse(jsonEditor.value);

                const nameSpan = document.getElementById('editFlowName');
                const nameInput = document.getElementById('editFlowNameInput');
                const intervalInput = document.getElementById('editUpdateInterval');

                if (nameSpan) nameSpan.textContent = flowData.name || '';
                if (nameInput) nameInput.value = flowData.name || '';
                if (intervalInput) intervalInput.value = flowData.update_interval_seconds || 60;
                setJsonValidationStatus(true, 'Valid JSON');
                return true;
            } catch (error) {
                console.warn('Failed to sync basic form from JSON:', error);
                setJsonValidationStatus(false, `Invalid JSON: ${error.message}`);
                showToast('Invalid JSON. Fix it before switching tabs.', 'error', 4000);
                return false;
            }
        }

        function setJsonValidationStatus(isValid, message) {
            const statusEl = document.getElementById('jsonValidationStatus');
            if (!statusEl) return;
            statusEl.textContent = message || '';
            statusEl.classList.toggle('ok', !!isValid);
            statusEl.classList.toggle('error', !isValid);
        }

        function formatFlowJSON() {
            const jsonEditor = document.getElementById('editFlowJSON');
            if (!jsonEditor) return;

            try {
                const parsed = JSON.parse(jsonEditor.value);
                jsonEditor.value = JSON.stringify(parsed, null, 2);
                setJsonValidationStatus(true, 'Formatted JSON');
                showToast('JSON formatted', 'success', 2000);
            } catch (error) {
                setJsonValidationStatus(false, `Invalid JSON: ${error.message}`);
                showToast('Invalid JSON: ' + error.message, 'error', 4000);
            }
        }

        function validateFlowJSON(silent = false) {
            const jsonEditor = document.getElementById('editFlowJSON');
            if (!jsonEditor) return;

            try {
                JSON.parse(jsonEditor.value);
                setJsonValidationStatus(true, 'Valid JSON');
                if (!silent) showToast('JSON is valid', 'success', 2000);
            } catch (error) {
                setJsonValidationStatus(false, `Invalid JSON: ${error.message}`);
                if (!silent) showToast('Invalid JSON: ' + error.message, 'error', 4000);
            }
        }

        async function copyFlowJSON() {
            const jsonEditor = document.getElementById('editFlowJSON');
            if (!jsonEditor) return;

            try {
                if (navigator.clipboard?.writeText) {
                    await navigator.clipboard.writeText(jsonEditor.value);
                } else {
                    jsonEditor.select();
                    document.execCommand('copy');
                }
                showToast('JSON copied to clipboard', 'success', 2000);
            } catch (error) {
                showToast('Failed to copy JSON: ' + error.message, 'error', 4000);
            }
        }

        function queueValidateFlowJSON() {
            clearTimeout(window.__jsonValidateTimer);
            window.__jsonValidateTimer = setTimeout(() => validateFlowJSON(true), 300);
        }

        function editFlow(deviceId, flowId) {
            // Find the flow to edit
            const flow = flows.find(f => f.device_id === deviceId && f.flow_id === flowId);
            if (!flow) {
                showToast('Flow not found', 'error');
                return;
            }

            // Store reference for saving
            editingFlow = { deviceId, flowId, flow };

            // Populate basic form (use actual element IDs from the HTML)
            const nameSpan = document.getElementById('editFlowName');
            if (nameSpan) nameSpan.textContent = flow.name || '';

            const nameInput = document.getElementById('editFlowNameInput');
            if (nameInput) nameInput.value = flow.name || '';

            const intervalInput = document.getElementById('editUpdateInterval');
            if (intervalInput) intervalInput.value = flow.update_interval_seconds || 60;

            // Populate JSON editor
            const jsonEditor = document.getElementById('editFlowJSON');
            if (jsonEditor) jsonEditor.value = JSON.stringify(flow, null, 2);
            setJsonValidationStatus(true, 'Loaded');

            // Reset to basic tab
            currentEditTab = 'basic';
            const tabBasic = document.getElementById('tabBasic');
            const tabJSON = document.getElementById('tabJSON');
            const basicEditor = document.getElementById('basicEditor');
            const jsonEditorPanel = document.getElementById('jsonEditor');

            if (tabBasic) tabBasic.classList.add('active');
            if (tabJSON) tabJSON.classList.remove('active');
            if (basicEditor) basicEditor.style.display = 'block';
            if (jsonEditorPanel) jsonEditorPanel.style.display = 'none';

            // Render the flow steps in the basic editor
            renderFlowSteps();

            // Show modal
            document.getElementById('editModal').classList.add('active');
        }

        function closeEditModal() {
            document.getElementById('editModal').classList.remove('active');
            editingFlow = null;
            currentEditTab = 'basic';
        }

        // Save flow edit function (called from Save button onclick)
        async function saveFlowEdit() {
            if (!editingFlow) return;

            let updatedFlow;

            try {
                // If on JSON tab, parse JSON
                if (currentEditTab === 'json' || currentEditTab === 'advanced') {
                    const jsonText = document.getElementById('editFlowJSON').value;
                    updatedFlow = JSON.parse(jsonText);

                    // Validate flow structure
                    if (!updatedFlow.flow_id || !updatedFlow.device_id) {
                        throw new Error('Invalid flow JSON: missing flow_id or device_id');
                    }
                } else {
                    // Use basic form values (only existing elements)
                    updatedFlow = {
                        ...editingFlow.flow
                    };

                    const nameInput = document.getElementById('editFlowNameInput');
                    const intervalInput = document.getElementById('editUpdateInterval');

                    if (nameInput) updatedFlow.name = nameInput.value;
                    if (intervalInput) updatedFlow.update_interval_seconds = parseInt(intervalInput.value);
                }

                await window.flowManager.updateFlow(editingFlow.deviceId, editingFlow.flowId, updatedFlow);
                showToast('Flow updated successfully', 'success');
                closeEditModal();
                await loadFlows();
            } catch (error) {
                if (error instanceof SyntaxError) {
                    showToast('Invalid JSON: ' + error.message, 'error', 5000);
                } else {
                    showToast('Failed to update flow: ' + error.message, 'error', 5000);
                }
            }
        }

        // Close modal when clicking outside
        document.getElementById('editModal').addEventListener('click', (e) => {
            if (e.target.id === 'editModal') {
                closeEditModal();
            }
        });

        // Make functions globally available
        window.loadFlows = loadFlows;
        window.loadAlerts = loadAlerts;
        window.clearAllAlerts = clearAllAlerts;
        window.dismissAlert = dismissAlert;
        window.executeFlow = executeFlow;
        window.testFlow = testFlow;
        window.testCurrentFlow = testCurrentFlow;
        window.deleteFlow = deleteFlow;
        window.editFlow = editFlow;
        window.closeEditModal = closeEditModal;
        window.switchEditTab = switchEditTab;
        window.toggleFlowEnabled = toggleFlowEnabled;
        window.addNewStep = addNewStep;
        window.deleteStep = deleteStep;
        window.moveStepUp = moveStepUp;
        window.moveStepDown = moveStepDown;
        window.updateStepField = updateStepField;
        window.renderFlowSteps = renderFlowSteps;
        window.pauseScheduler = pauseScheduler;
        window.resumeScheduler = resumeScheduler;
        window.clearQueue = clearQueue;
        window.loadSchedulerStatus = loadSchedulerStatus;
        window.showInsertSensorDialog = showInsertSensorDialog;
        window.showInsertActionDialog = showInsertActionDialog;
        window.saveFlowEdit = saveFlowEdit;
        window.formatFlowJSON = formatFlowJSON;
        window.validateFlowJSON = validateFlowJSON;
        window.copyFlowJSON = copyFlowJSON;
        window.queueValidateFlowJSON = queueValidateFlowJSON;

        // ==========================================================================
        // Template Picker Functions
        // ==========================================================================

        let templates = [];
        let selectedTemplate = null;
        let templateStep = 1;

        async function showTemplatePickerModal() {
            const modal = document.getElementById('templatePickerModal');
            modal.style.display = 'flex';

            // Reset state
            selectedTemplate = null;
            templateStep = 1;
            document.getElementById('templateStep1').style.display = 'block';
            document.getElementById('templateStep2').style.display = 'none';
            document.getElementById('templateBackBtn').style.display = 'none';
            document.getElementById('templateNextBtn').style.display = 'none';
            document.getElementById('templateCreateBtn').style.display = 'none';

            // Load templates
            await loadTemplates();
        }

        function closeTemplatePickerModal() {
            document.getElementById('templatePickerModal').style.display = 'none';
            selectedTemplate = null;
            templateStep = 1;
        }

        async function loadTemplates() {
            const grid = document.getElementById('templateGrid');
            grid.innerHTML = '<p class="loading">Loading templates...</p>';

            try {
                const response = await fetch(`${window.flowManager.apiBase}/flow-templates`);
                if (!response.ok) throw new Error('Failed to load templates');

                const data = await response.json();
                templates = data.templates || [];

                if (templates.length === 0) {
                    grid.innerHTML = `
                        <div class="empty-state" style="grid-column: 1 / -1; text-align: center; padding: 40px;">
                            <p>No templates available yet.</p>
                            <p style="color: var(--text-secondary);">Create a flow and save it as a template to get started.</p>
                        </div>
                    `;
                    return;
                }

                grid.innerHTML = templates.map(template => `
                    <div class="template-card ${selectedTemplate?.template_id === template.template_id ? 'selected' : ''}"
                         onclick="selectTemplate('${template.template_id}')"
                         data-template-id="${template.template_id}">
                        <div class="template-icon">${template.builtin ? 'üì¶' : 'üìÑ'}</div>
                        <div class="template-info">
                            <h4>${escapeHtml(template.name)}</h4>
                            <p>${escapeHtml(template.description || 'No description')}</p>
                            <div class="template-meta">
                                <span class="template-steps">${template.step_count || 0} steps</span>
                                ${template.tags && template.tags.length > 0 ?
                                    template.tags.slice(0, 3).map(tag =>
                                        `<span class="template-tag">${escapeHtml(tag)}</span>`
                                    ).join('') : ''
                                }
                            </div>
                        </div>
                    </div>
                `).join('');

            } catch (error) {
                console.error('Failed to load templates:', error);
                grid.innerHTML = `
                    <div class="error-state" style="grid-column: 1 / -1; text-align: center; padding: 40px; color: #ef4444;">
                        <p>Failed to load templates: ${escapeHtml(error.message)}</p>
                        <button class="btn btn-secondary" onclick="loadTemplates()">Retry</button>
                    </div>
                `;
            }
        }

        function selectTemplate(templateId) {
            selectedTemplate = templates.find(t => t.template_id === templateId);

            // Update visual selection
            document.querySelectorAll('.template-card').forEach(card => {
                card.classList.toggle('selected', card.dataset.templateId === templateId);
            });

            // Show Next button
            document.getElementById('templateNextBtn').style.display = 'inline-block';
        }

        async function templateGoNext() {
            if (!selectedTemplate) {
                showToast('Please select a template', 'warning');
                return;
            }

            templateStep = 2;
            document.getElementById('templateStep1').style.display = 'none';
            document.getElementById('templateStep2').style.display = 'block';
            document.getElementById('templateBackBtn').style.display = 'inline-block';
            document.getElementById('templateNextBtn').style.display = 'none';
            document.getElementById('templateCreateBtn').style.display = 'inline-block';

            // Show template preview
            const preview = document.getElementById('templatePreview');
            preview.innerHTML = `
                <div class="template-header">
                    <span class="template-icon">${selectedTemplate.builtin ? 'üì¶' : 'üìÑ'}</span>
                    <div>
                        <h4>${escapeHtml(selectedTemplate.name)}</h4>
                        <p>${escapeHtml(selectedTemplate.description || '')}</p>
                    </div>
                </div>
            `;

            // Pre-fill flow name
            document.getElementById('templateFlowName').value = selectedTemplate.name + ' Flow';

            // Load devices for selector
            try {
                const devicesResponse = await fetch(`${window.flowManager.apiBase}/adb/devices`);
                if (devicesResponse.ok) {
                    const devicesData = await devicesResponse.json();
                    const devices = devicesData.devices || [];

                    const select = document.getElementById('templateDeviceSelect');
                    select.innerHTML = '<option value="">Select a device...</option>' +
                        devices.map(d => `<option value="${d.id}">${d.model || d.id}</option>`).join('');
                }
            } catch (error) {
                console.error('Failed to load devices:', error);
            }

            // Show steps preview
            const stepsPreview = document.getElementById('templateStepsPreview');
            const steps = selectedTemplate.steps || [];
            stepsPreview.innerHTML = steps.length > 0 ?
                `<ol class="steps-list">
                    ${steps.map((step, i) => `
                        <li class="step-preview-item">
                            <span class="step-type-badge">${step.step_type}</span>
                            <span class="step-desc">${escapeHtml(step.description || '')}</span>
                        </li>
                    `).join('')}
                </ol>` :
                '<p style="color: var(--text-secondary);">No steps defined</p>';
        }

        function templateGoBack() {
            templateStep = 1;
            document.getElementById('templateStep1').style.display = 'block';
            document.getElementById('templateStep2').style.display = 'none';
            document.getElementById('templateBackBtn').style.display = 'none';
            document.getElementById('templateNextBtn').style.display = selectedTemplate ? 'inline-block' : 'none';
            document.getElementById('templateCreateBtn').style.display = 'none';
        }

        async function createFlowFromTemplate() {
            const flowName = document.getElementById('templateFlowName').value.trim();
            const deviceId = document.getElementById('templateDeviceSelect').value;

            if (!flowName) {
                showToast('Please enter a flow name', 'warning');
                return;
            }

            if (!deviceId) {
                showToast('Please select a device', 'warning');
                return;
            }

            try {
                const response = await fetch(`${window.flowManager.apiBase}/flow-templates/${selectedTemplate.template_id}/create-flow`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        device_id: deviceId,
                        flow_name: flowName
                    })
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.detail || 'Failed to create flow');
                }

                const result = await response.json();
                showToast(`Flow "${flowName}" created successfully!`, 'success');
                closeTemplatePickerModal();
                await loadFlows();

            } catch (error) {
                console.error('Failed to create flow from template:', error);
                showToast('Failed to create flow: ' + error.message, 'error');
            }
        }

        // ==========================================================================
        // Save as Template Functions
        // ==========================================================================

        function saveFlowAsTemplate() {
            if (!editingFlow) {
                showToast('No flow selected', 'error');
                return;
            }

            // Show save template modal
            document.getElementById('saveTemplateModal').style.display = 'flex';
            document.getElementById('newTemplateName').value = editingFlow.flow.name + ' Template';
            document.getElementById('newTemplateTags').value = '';
        }

        function closeSaveTemplateModal() {
            document.getElementById('saveTemplateModal').style.display = 'none';
        }

        async function confirmSaveAsTemplate() {
            const templateName = document.getElementById('newTemplateName').value.trim();
            const tagsInput = document.getElementById('newTemplateTags').value.trim();

            if (!templateName) {
                showToast('Please enter a template name', 'warning');
                return;
            }

            const tags = tagsInput ? tagsInput.split(',').map(t => t.trim()).filter(t => t) : [];

            try {
                const response = await fetch(`${window.flowManager.apiBase}/flows/${editingFlow.deviceId}/${editingFlow.flowId}/save-as-template`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        template_name: templateName,
                        tags: tags
                    })
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.detail || 'Failed to save template');
                }

                const result = await response.json();
                showToast(`Template "${templateName}" saved!`, 'success');
                closeSaveTemplateModal();

            } catch (error) {
                console.error('Failed to save as template:', error);
                showToast('Failed to save template: ' + error.message, 'error');
            }
        }

        // Make template functions globally available
        window.showTemplatePickerModal = showTemplatePickerModal;
        window.closeTemplatePickerModal = closeTemplatePickerModal;
        window.loadTemplates = loadTemplates;
        window.selectTemplate = selectTemplate;
        window.templateGoNext = templateGoNext;
        window.templateGoBack = templateGoBack;
        window.createFlowFromTemplate = createFlowFromTemplate;
        window.saveFlowAsTemplate = saveFlowAsTemplate;
        window.closeSaveTemplateModal = closeSaveTemplateModal;
        window.confirmSaveAsTemplate = confirmSaveAsTemplate;

        // ==========================================================================
        // Import/Export Functions
        // ==========================================================================

        let importData = null;

        async function showImportModal() {
            document.getElementById('importFlowModal').style.display = 'flex';
            importData = null;
            document.getElementById('importPreview').style.display = 'none';
            document.getElementById('confirmImportBtn').disabled = true;

            // Load devices
            await loadDevicesForImport();

            // Set up import method toggle
            document.querySelectorAll('input[name="importMethod"]').forEach(radio => {
                radio.addEventListener('change', (e) => {
                    document.getElementById('importFileSection').style.display = e.target.value === 'file' ? 'block' : 'none';
                    document.getElementById('importPasteSection').style.display = e.target.value === 'paste' ? 'block' : 'none';
                });
            });

            // Set up file input
            document.getElementById('importFile').addEventListener('change', handleImportFile);
            document.getElementById('importPasteJSON').addEventListener('input', handleImportPaste);
        }

        function closeImportModal() {
            document.getElementById('importFlowModal').style.display = 'none';
            importData = null;
        }

        async function loadDevicesForImport() {
            try {
                const response = await fetch(`${window.flowManager.apiBase}/adb/devices`);
                if (response.ok) {
                    const data = await response.json();
                    const devices = data.devices || [];
                    const select = document.getElementById('importDeviceSelect');
                    select.innerHTML = '<option value="">Select target device...</option>' +
                        devices.map(d => `<option value="${d.id}">${d.model || d.id}</option>`).join('');
                }
            } catch (error) {
                console.error('Failed to load devices:', error);
            }
        }

        function handleImportFile(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    importData = JSON.parse(e.target.result);
                    showImportPreview(importData);
                } catch (error) {
                    showToast('Invalid JSON file', 'error');
                    importData = null;
                }
            };
            reader.readAsText(file);
        }

        function handleImportPaste() {
            const text = document.getElementById('importPasteJSON').value.trim();
            if (!text) {
                importData = null;
                document.getElementById('importPreview').style.display = 'none';
                document.getElementById('confirmImportBtn').disabled = true;
                return;
            }

            try {
                importData = JSON.parse(text);
                showImportPreview(importData);
            } catch (error) {
                importData = null;
                document.getElementById('importPreview').style.display = 'none';
                document.getElementById('confirmImportBtn').disabled = true;
            }
        }

        function showImportPreview(data) {
            const preview = document.getElementById('importPreview');
            const content = document.getElementById('importPreviewContent');

            let html = '';
            if (data.export_type === 'single_flow') {
                html = `
                    <p><strong>Type:</strong> Single Flow</p>
                    <p><strong>Name:</strong> ${escapeHtml(data.flow_name || data.flow?.name || 'Unknown')}</p>
                    <p><strong>App:</strong> ${escapeHtml(data.app_package || 'Unknown')}</p>
                    <p><strong>Steps:</strong> ${data.flow?.steps?.length || 0}</p>
                    <p><strong>Sensors:</strong> ${data.sensor_count || 0}</p>
                `;
            } else if (data.export_type === 'device_flows') {
                html = `
                    <p><strong>Type:</strong> Device Flows Export</p>
                    <p><strong>Flows:</strong> ${data.flow_count || 0}</p>
                    <p><strong>Sensors:</strong> ${data.sensor_count || 0}</p>
                    <p><strong>From Device:</strong> ${escapeHtml(data.device_id || 'Unknown')}</p>
                `;
            } else {
                html = `<p><strong>Type:</strong> ${escapeHtml(data.export_type || 'Unknown')}</p>`;
            }

            content.innerHTML = html;
            preview.style.display = 'block';
            document.getElementById('confirmImportBtn').disabled = false;
        }

        async function confirmImport() {
            const deviceId = document.getElementById('importDeviceSelect').value;
            if (!deviceId) {
                showToast('Please select a target device', 'warning');
                return;
            }

            if (!importData) {
                showToast('No import data', 'error');
                return;
            }

            try {
                const response = await fetch(`${window.flowManager.apiBase}/flows/import/${encodeURIComponent(deviceId)}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(importData)
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.detail || 'Import failed');
                }

                const result = await response.json();
                showToast(result.message, 'success');
                closeImportModal();
                await loadFlows();

            } catch (error) {
                console.error('Import failed:', error);
                showToast('Import failed: ' + error.message, 'error');
            }
        }

        async function exportFlow(deviceId, flowId) {
            try {
                const response = await fetch(`${window.flowManager.apiBase}/flows/${encodeURIComponent(deviceId)}/${encodeURIComponent(flowId)}/export`);
                if (!response.ok) throw new Error('Export failed');

                const data = await response.json();

                // Download as JSON file
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `flow_${data.flow_name || flowId}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                showToast('Flow exported successfully', 'success');
            } catch (error) {
                console.error('Export failed:', error);
                showToast('Export failed: ' + error.message, 'error');
            }
        }

        // Make import/export functions globally available
        window.showImportModal = showImportModal;
        window.closeImportModal = closeImportModal;
        window.confirmImport = confirmImport;
        window.exportFlow = exportFlow;

        // ==========================================================================
        // Bundled App Flows Functions
        // ==========================================================================

        let bundledFlows = [];

        async function showBundledFlowsModal() {
            document.getElementById('bundledFlowsModal').style.display = 'flex';

            // Load devices
            await loadDevicesForBundled();

            // Load bundled flows
            await loadBundledFlows();
        }

        function closeBundledFlowsModal() {
            document.getElementById('bundledFlowsModal').style.display = 'none';
        }

        async function loadDevicesForBundled() {
            try {
                const response = await fetch(`${window.flowManager.apiBase}/adb/devices`);
                if (response.ok) {
                    const data = await response.json();
                    const devices = data.devices || [];
                    const select = document.getElementById('bundledDeviceSelect');
                    select.innerHTML = '<option value="">Select target device...</option>' +
                        devices.map(d => `<option value="${d.id}">${d.model || d.id}</option>`).join('');
                }
            } catch (error) {
                console.error('Failed to load devices:', error);
            }
        }

        async function loadBundledFlows() {
            const grid = document.getElementById('bundledFlowsGrid');
            grid.innerHTML = '<p class="loading">Loading available app flows...</p>';

            try {
                const response = await fetch(`${window.flowManager.apiBase}/app-flows`);
                if (!response.ok) throw new Error('Failed to load bundled flows');

                const data = await response.json();
                const apps = data.apps || [];

                if (apps.length === 0) {
                    grid.innerHTML = '<p>No bundled app flows available.</p>';
                    return;
                }

                grid.innerHTML = apps.map(app => `
                    <div class="bundled-app-section">
                        <h4 class="app-header">${escapeHtml(app.app_name)}</h4>
                        <p class="app-package">${escapeHtml(app.app_package)}</p>
                        <div class="app-flows">
                            ${app.flows.map(flow => `
                                <div class="bundled-flow-card" data-bundle-id="${flow.bundle_id}">
                                    <div class="flow-info">
                                        <h5>${escapeHtml(flow.name)}</h5>
                                        <p>${escapeHtml(flow.description)}</p>
                                        <span class="badge">${flow.step_count} steps</span>
                                    </div>
                                    <button class="btn btn-sm btn-primary" onclick="installBundledFlow('${flow.bundle_id}')">
                                        Install
                                    </button>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `).join('');

            } catch (error) {
                console.error('Failed to load bundled flows:', error);
                grid.innerHTML = `<p class="error">Failed to load: ${escapeHtml(error.message)}</p>`;
            }
        }

        async function installBundledFlow(bundleId) {
            const deviceId = document.getElementById('bundledDeviceSelect').value;
            if (!deviceId) {
                showToast('Please select a target device first', 'warning');
                return;
            }

            try {
                const response = await fetch(`${window.flowManager.apiBase}/app-flows/${bundleId}/install`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ device_id: deviceId })
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.detail || 'Install failed');
                }

                const result = await response.json();
                showToast(result.message, 'success');
                closeBundledFlowsModal();
                await loadFlows();

            } catch (error) {
                console.error('Install failed:', error);
                showToast('Install failed: ' + error.message, 'error');
            }
        }

        // Make bundled flow functions globally available
        window.showBundledFlowsModal = showBundledFlowsModal;
        window.closeBundledFlowsModal = closeBundledFlowsModal;
        window.installBundledFlow = installBundledFlow;

        // =============================================================
        // SMART FLOW GENERATOR FUNCTIONS
        // =============================================================

        let generatedSmartFlow = null;
        let companionAppInfo = null;

        async function showSmartFlowModal() {
            const modal = document.getElementById('smartFlowModal');
            modal.style.display = 'flex';

            // Reset state
            generatedSmartFlow = null;
            companionAppInfo = null;
            document.getElementById('smartFlowPreview').style.display = 'none';
            document.getElementById('btnSaveSmartFlow').style.display = 'none';
            document.getElementById('btnTestSmartFlow').style.display = 'none';
            document.getElementById('btnGenerateSmartFlow').disabled = true;
            document.getElementById('discoveryModeGroup').style.display = 'none';
            document.getElementById('navDataPanel').style.display = 'none';
            document.getElementById('companionStatusPanel').style.display = 'none';

            // Load devices
            const deviceSelect = document.getElementById('smartFlowDevice');
            deviceSelect.innerHTML = '<option value="">Loading devices...</option>';

            try {
                const response = await fetch(`${window.flowManager.apiBase}/adb/devices`);
                const data = await response.json();
                const devices = data.devices || [];

                deviceSelect.innerHTML = '<option value="">Select device...</option>';
                // Filter for connected devices (state='device' means ready, connected=true is online)
                devices.filter(d => d.state === 'device' && d.connected !== false).forEach(device => {
                    const option = document.createElement('option');
                    option.value = device.id;
                    option.textContent = device.model || device.id;
                    deviceSelect.appendChild(option);
                });
            } catch (error) {
                console.error('Failed to load devices:', error);
                deviceSelect.innerHTML = '<option value="">Error loading devices</option>';
            }
        }

        async function checkCompanionAppStatus(deviceId) {
            // Convert ADB device ID to stable format for companion app lookup
            // e.g., "192.168.1.2:46747" -> "192_168_86_2_46747" or similar variations
            const statusPanel = document.getElementById('companionStatusPanel');
            const statusIndicator = document.getElementById('companionStatusIndicator');
            const liveDiscoveryOption = document.getElementById('liveDiscoveryOption');

            statusPanel.style.display = 'block';
            statusIndicator.innerHTML = `
                <span class="status-dot checking"></span>
                <span class="status-text">Checking for companion app...</span>
            `;

            try {
                const response = await fetch(`${window.flowManager.apiBase}/devices`);
                const data = await response.json();
                const devices = data.devices || [];

                // Try to find matching device (may be stored with different ID format)
                const normalizedId = deviceId.replace(/[:.]/g, '_');
                const matchingDevice = devices.find(d =>
                    d.deviceId === normalizedId ||
                    d.deviceId === deviceId ||
                    d.deviceId.includes(normalizedId.split('_').slice(0, 4).join('_'))
                );

                if (matchingDevice) {
                    companionAppInfo = matchingDevice;
                    const hasAccessibility = matchingDevice.capabilities?.includes('accessibility');

                    statusIndicator.innerHTML = `
                        <span class="status-dot connected"></span>
                        <span class="status-text">Companion app connected: ${matchingDevice.deviceName}</span>
                        ${hasAccessibility ? '<span class="status-badge">Accessibility enabled</span>' : ''}
                    `;

                    // Show live discovery option if accessibility is available
                    if (hasAccessibility) {
                        liveDiscoveryOption.style.display = 'block';
                    }
                } else {
                    companionAppInfo = null;
                    statusIndicator.innerHTML = `
                        <span class="status-dot disconnected"></span>
                        <span class="status-text">Companion app not connected</span>
                        <span class="status-hint">Install and run the Visual Mapper app on the device for live discovery</span>
                    `;
                    liveDiscoveryOption.style.display = 'none';
                }
            } catch (error) {
                console.error('Failed to check companion app status:', error);
                statusIndicator.innerHTML = `
                    <span class="status-dot error"></span>
                    <span class="status-text">Could not check companion app status</span>
                `;
            }
        }

        async function onSmartFlowDeviceChange() {
            const deviceId = document.getElementById('smartFlowDevice').value;
            const appSelect = document.getElementById('smartFlowApp');
            const generateBtn = document.getElementById('btnGenerateSmartFlow');
            const discoveryModeGroup = document.getElementById('discoveryModeGroup');
            const navDataPanel = document.getElementById('navDataPanel');

            if (!deviceId) {
                appSelect.innerHTML = '<option value="">Select device first...</option>';
                appSelect.disabled = true;
                generateBtn.disabled = true;
                discoveryModeGroup.style.display = 'none';
                navDataPanel.style.display = 'none';
                document.getElementById('companionStatusPanel').style.display = 'none';
                return;
            }

            // Check companion app status in parallel with loading navigation data
            checkCompanionAppStatus(deviceId);

            appSelect.innerHTML = '<option value="">Loading apps with navigation data...</option>';
            appSelect.disabled = true;
            discoveryModeGroup.style.display = 'block';

            try {
                // Get list of apps with navigation data
                const navResponse = await fetch(`${window.flowManager.apiBase}/navigation/`);
                const navData = await navResponse.json();
                const packages = navData.packages || [];

                if (packages.length === 0) {
                    appSelect.innerHTML = '<option value="">No apps with navigation data found</option>';
                    navDataPanel.style.display = 'block';
                    document.getElementById('navDataStats').innerHTML = `
                        <div class="nav-no-data">
                            <div class="nav-icon">üì±</div>
                            <div class="nav-message">No navigation data available</div>
                            <div class="nav-hint">
                                <strong>To get started:</strong>
                                <ul>
                                    <li>Record flows manually using the Flow Wizard - navigation is learned automatically</li>
                                    <li>Or, use the Visual Mapper companion app with accessibility enabled for live discovery</li>
                                </ul>
                            </div>
                        </div>
                    `;
                    return;
                }

                appSelect.innerHTML = '<option value="">Select app...</option>';
                appSelect.disabled = false;

                // Add each app with navigation data
                for (const pkg of packages) {
                    const option = document.createElement('option');
                    option.value = pkg;
                    // Get app name from package
                    const appName = pkg.split('.').pop().charAt(0).toUpperCase() + pkg.split('.').pop().slice(1);
                    option.textContent = `${appName} (${pkg})`;
                    appSelect.appendChild(option);
                }

                // Enable generate button when app is selected
                appSelect.onchange = async () => {
                    generateBtn.disabled = !appSelect.value;
                    document.getElementById('smartFlowPreview').style.display = 'none';
                    document.getElementById('btnSaveSmartFlow').style.display = 'none';
                    document.getElementById('btnTestSmartFlow').style.display = 'none';

                    // Show navigation stats for selected app
                    if (appSelect.value) {
                        await showNavDataStats(appSelect.value);
                    } else {
                        navDataPanel.style.display = 'none';
                    }
                };

            } catch (error) {
                console.error('Failed to load navigation data:', error);
                appSelect.innerHTML = '<option value="">Error loading apps</option>';
            }
        }

        async function showNavDataStats(packageName) {
            const navDataPanel = document.getElementById('navDataPanel');
            const navDataStats = document.getElementById('navDataStats');

            navDataPanel.style.display = 'block';
            navDataStats.innerHTML = '<div class="loading">Loading navigation stats...</div>';

            try {
                const response = await fetch(`${window.flowManager.apiBase}/navigation/${encodeURIComponent(packageName)}/stats`);

                if (!response.ok) {
                    navDataStats.innerHTML = '<div class="nav-no-data">No detailed stats available</div>';
                    return;
                }

                const data = await response.json();
                const stats = data.stats;

                navDataStats.innerHTML = `
                    <div class="nav-stats-grid">
                        <div class="nav-stat">
                            <span class="stat-value">${stats.screen_count || 0}</span>
                            <span class="stat-label">Screens</span>
                        </div>
                        <div class="nav-stat">
                            <span class="stat-value">${stats.transition_count || 0}</span>
                            <span class="stat-label">Transitions</span>
                        </div>
                        <div class="nav-stat">
                            <span class="stat-value">${stats.home_screen_id ? '‚úì' : '‚úó'}</span>
                            <span class="stat-label">Home Screen</span>
                        </div>
                    </div>
                    <div class="nav-hint">
                        ${stats.screen_count > 0
                            ? 'Navigation data is available. Click Generate Flow to create an automated flow.'
                            : 'Limited navigation data. Record more flows to improve coverage.'}
                    </div>
                `;
            } catch (error) {
                console.error('Failed to load navigation stats:', error);
                navDataStats.innerHTML = '<div class="nav-no-data">Could not load stats</div>';
            }
        }

        function onDiscoveryModeChange() {
            const mode = document.querySelector('input[name="discoveryMode"]:checked')?.value;
            const appSelectGroup = document.getElementById('appSelectGroup');
            const generateBtn = document.getElementById('btnGenerateSmartFlow');
            const deviceId = document.getElementById('smartFlowDevice').value;

            if (mode === 'live') {
                // Hide app selector for live mode (will discover from current app)
                appSelectGroup.style.display = 'none';
                document.getElementById('navDataPanel').style.display = 'none';
                // Enable if device is selected
                generateBtn.disabled = !deviceId;
                generateBtn.textContent = 'Discover & Generate';
            } else {
                // Show app selector for navigation mode
                appSelectGroup.style.display = 'block';
                const appSelect = document.getElementById('smartFlowApp');
                generateBtn.disabled = !appSelect.value;
                generateBtn.textContent = 'Generate Flow';
            }
        }

        function onSmartFlowAppChange() {
            const appSelect = document.getElementById('smartFlowApp');
            const generateBtn = document.getElementById('btnGenerateSmartFlow');
            const packageName = appSelect.value;

            // Enable Generate button if app is selected
            generateBtn.disabled = !packageName;

            // Load navigation stats for this app if selected
            if (packageName) {
                loadNavigationStats(packageName);
            }
        }

        async function generateSmartFlow() {
            const deviceId = document.getElementById('smartFlowDevice').value;
            const discoveryMode = document.querySelector('input[name="discoveryMode"]:checked')?.value || 'navigation';
            const includeScreenshots = document.getElementById('smartFlowScreenshots').checked;
            const includeSensors = document.getElementById('smartFlowSensors').checked;

            if (!deviceId) {
                showToast('Please select a device', 'warning');
                return;
            }

            const generateBtn = document.getElementById('btnGenerateSmartFlow');
            generateBtn.disabled = true;

            try {
                if (discoveryMode === 'live') {
                    // Live discovery mode - request UI tree from companion app
                    await generateSmartFlowLive(deviceId, includeScreenshots, includeSensors);
                } else {
                    // Navigation mode - use stored navigation graph
                    await generateSmartFlowFromNavigation(deviceId, includeScreenshots, includeSensors);
                }
            } catch (error) {
                console.error('Smart flow generation failed:', error);
                showToast('Generation failed: ' + error.message, 'error');
            } finally {
                generateBtn.disabled = false;
                generateBtn.textContent = discoveryMode === 'live' ? 'Discover & Generate' : 'Generate Flow';
            }
        }

        async function generateSmartFlowLive(deviceId, includeScreenshots, includeSensors) {
            const generateBtn = document.getElementById('btnGenerateSmartFlow');
            generateBtn.textContent = 'Discovering elements...';

            // First, get selectable elements from companion app
            const response = await fetch(`${window.flowManager.apiBase}/companion/select-elements`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    device_id: deviceId,
                    timeout: 15.0
                })
            });

            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.detail || 'Failed to get UI elements from companion app');
            }

            const uiData = await response.json();

            if (!uiData.success) {
                throw new Error(uiData.error || 'Failed to discover elements');
            }

            generateBtn.textContent = 'Generating flow...';

            // Build flow steps from discovered elements
            const flowSteps = [];
            const categories = uiData.categories || {};

            // Add navigation steps (buttons that navigate)
            (categories.navigation || []).forEach(el => {
                flowSteps.push({
                    step_type: 'action',
                    action_type: 'tap',
                    target: {
                        resource_id: el.resource_id,
                        bounds: el.bounds
                    },
                    description: `Tap ${el.text || el.content_desc || el.resource_id || 'navigation element'}`
                });
            });

            // Add button taps
            (categories.buttons || []).forEach(el => {
                flowSteps.push({
                    step_type: 'action',
                    action_type: 'tap',
                    target: {
                        resource_id: el.resource_id,
                        bounds: el.bounds
                    },
                    description: `Tap ${el.text || el.content_desc || el.resource_id || 'button'}`
                });
            });

            // Add text elements as potential sensors
            if (includeSensors) {
                (categories.text || []).forEach(el => {
                    flowSteps.push({
                        step_type: 'sensor',
                        sensor_type: 'text',
                        target: {
                            resource_id: el.resource_id,
                            bounds: el.bounds
                        },
                        description: `Read text from ${el.resource_id || 'element'}: "${el.text?.substring(0, 30) || ''}"...`
                    });
                });
            }

            // Add screenshot if requested
            if (includeScreenshots) {
                flowSteps.unshift({
                    step_type: 'screenshot',
                    description: `Capture screenshot of ${uiData.activity || 'current screen'}`
                });
            }

            // Create the flow object
            generatedSmartFlow = {
                name: `Smart Flow - ${uiData.package || 'App'} (Live Discovery)`,
                device_id: deviceId,
                package_name: uiData.package,
                trigger: 'manual',
                steps: flowSteps,
                metadata: {
                    created_from: 'live_discovery',
                    activity: uiData.activity,
                    discovered_at: new Date().toISOString()
                }
            };

            // Show preview
            showSmartFlowPreview({
                flow: generatedSmartFlow,
                screens_covered: 1,
                total_screens: 1,
                sensors_found: (categories.text || []).length,
                message: `Discovered ${uiData.element_count} elements from ${uiData.activity || 'current screen'}`
            });
        }

        async function generateSmartFlowFromNavigation(deviceId, includeScreenshots, includeSensors) {
            const packageName = document.getElementById('smartFlowApp').value;

            if (!packageName) {
                showToast('Please select an app', 'warning');
                return;
            }

            const generateBtn = document.getElementById('btnGenerateSmartFlow');
            generateBtn.textContent = 'Generating...';

            const response = await fetch(`${window.flowManager.apiBase}/flows/generate-smart`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    device_id: deviceId,
                    package_name: packageName,
                    include_screenshots: includeScreenshots,
                    capture_mode: includeSensors ? 'all_screens' : 'screenshots_only'
                })
            });

            const result = await response.json();

            if (!result.success) {
                showToast(result.message || 'Generation failed', 'error');
                return;
            }

            // Store generated flow
            generatedSmartFlow = result.flow;
            showSmartFlowPreview(result);
        }

        // Track if steps are expanded
        let smartFlowStepsExpanded = false;
        // Store sensor selection state
        window._smartFlowSensors = [];

        function showSmartFlowPreview(result) {
            const previewDiv = document.getElementById('smartFlowPreview');
            const statsDiv = document.getElementById('smartFlowStats');
            const stepsDiv = document.getElementById('smartFlowSteps');
            const warningsDiv = document.getElementById('smartFlowWarnings');
            const sensorsListDiv = document.getElementById('smartFlowSensorsList');

            // Show warnings if any
            let warningsHtml = '';

            // Special handling for overlapping flows
            if (result.overlapping_flows && result.overlapping_flows.length > 0) {
                warningsHtml += `
                    <div class="overlap-section" style="background: #fff3cd; border: 1px solid #ffc107; padding: 12px; border-radius: 8px; margin-bottom: 12px;">
                        <div style="font-weight: 600; margin-bottom: 8px; color: #856404;">
                            üìã Overlapping Flows Detected
                        </div>
                        <div style="font-size: 0.9em; color: #664d03; margin-bottom: 8px;">
                            This flow captures sensors that are already covered by existing flows:
                        </div>
                        ${result.overlapping_flows.map(of => `
                            <div style="background: white; padding: 8px; border-radius: 4px; margin-bottom: 6px; display: flex; justify-content: space-between; align-items: center;">
                                <div>
                                    <strong>${of.flow_name}</strong>
                                    <div style="font-size: 0.8em; color: #666;">${of.similarity}% overlap</div>
                                </div>
                                <div style="font-size: 0.8em; color: #856404;">
                                    ${of.recommendation === 'use_existing' ? 'üí° Consider using existing' : '‚ö†Ô∏è Review recommended'}
                                </div>
                            </div>
                        `).join('')}
                        <div style="font-size: 0.85em; color: #664d03; margin-top: 8px;">
                            üí° <em>Tip: Consolidating flows reduces redundant sensor captures during scheduled runs.</em>
                        </div>
                    </div>
                `;
            }

            // Regular warnings
            if (result.warnings && result.warnings.length > 0) {
                warningsHtml += result.warnings.filter(w => !w.includes('Overlaps')).map(w => `
                    <div class="warning-item" style="background: #fef3cd; color: #856404; padding: 8px 12px; border-radius: 4px; margin-bottom: 8px; display: flex; align-items: center; gap: 8px;">
                        <span style="font-size: 1.2em;">‚ö†Ô∏è</span>
                        <span>${w}</span>
                    </div>
                `).join('');
            }

            if (warningsHtml) {
                warningsDiv.innerHTML = warningsHtml;
                warningsDiv.style.display = 'block';
            } else {
                warningsDiv.style.display = 'none';
            }

            const suggestionsCount = result.suggestions_count || (result.suggested_sensors ? result.suggested_sensors.length : 0);
            statsDiv.innerHTML = `
                <div class="stat-item">
                    <span class="stat-label">Screens Covered:</span>
                    <span class="stat-value">${result.screens_covered}/${result.safe_screens || result.total_screens}</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Total Steps:</span>
                    <span class="stat-value">${result.flow.steps.length}</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Existing Sensors:</span>
                    <span class="stat-value">${result.sensors_found}</span>
                </div>
                ${suggestionsCount > 0 ? `
                <div class="stat-item" style="color: #856404;">
                    <span class="stat-label">‚ú® New Detected:</span>
                    <span class="stat-value">${suggestionsCount}</span>
                </div>
                ` : ''}
            `;

            // Store sensors for toggling
            window._smartFlowSensors = result.sensors || [];
            renderSmartFlowSensors();

            // Store suggested sensors for toggling
            window._suggestedSensors = result.suggested_sensors || [];
            renderSuggestedSensors();

            // Store actions for toggling
            window._smartFlowActions = result.actions || [];
            renderSmartFlowActions();

            // Store all steps for toggling
            window._smartFlowAllSteps = result.flow.steps;
            smartFlowStepsExpanded = false;
            renderSmartFlowSteps(false);

            previewDiv.style.display = 'block';
            document.getElementById('btnTestSmartFlow').style.display = 'inline-block';
            document.getElementById('btnSaveSmartFlow').style.display = 'inline-block';
            showToast(result.message, 'success');
        }

        function renderSmartFlowSensors() {
            const sensorsListDiv = document.getElementById('smartFlowSensorsList');
            const sensors = window._smartFlowSensors || [];

            // Update tab count
            const countEl = document.getElementById('sensorsTabCount');
            if (countEl) countEl.textContent = sensors.length;

            if (sensors.length === 0) {
                sensorsListDiv.innerHTML = '<div style="color: #666; font-style: italic; padding: 8px;">No sensors found for this app</div>';
                return;
            }

            sensorsListDiv.innerHTML = sensors.map((sensor, i) => `
                <div class="sensor-item" style="display: flex; align-items: center; gap: 10px; padding: 8px; border-bottom: 1px solid #eee; ${!sensor.enabled ? 'opacity: 0.5;' : ''}">
                    <input type="checkbox"
                           id="smartSensor_${i}"
                           ${sensor.enabled ? 'checked' : ''}
                           onchange="toggleSmartFlowSensor(${i}, this.checked)"
                           style="width: 18px; height: 18px;">
                    <div style="flex: 1;">
                        <div style="font-weight: 500;">${sensor.name}</div>
                        <div style="font-size: 0.8em; color: #666;">
                            ${sensor.type} ¬∑ ${sensor.device_class || 'none'}${sensor.unit ? ' ¬∑ ' + sensor.unit : ''}
                        </div>
                        <div style="font-size: 0.75em; color: #999; font-family: monospace;">${sensor.entity_id}</div>
                    </div>
                </div>
            `).join('');
        }

        function toggleSmartFlowSensor(index, enabled) {
            if (window._smartFlowSensors && window._smartFlowSensors[index]) {
                window._smartFlowSensors[index].enabled = enabled;
                // Update the flow's sensor_ids based on enabled sensors
                updateSmartFlowSensorIds();
            }
        }

        function toggleAllSmartFlowSensors(enabled) {
            if (window._smartFlowSensors) {
                window._smartFlowSensors.forEach(s => s.enabled = enabled);
                renderSmartFlowSensors();
                updateSmartFlowSensorIds();
            }
        }

        function updateSmartFlowSensorIds() {
            // Update the capture_sensors step in the generated flow
            if (generatedSmartFlow && generatedSmartFlow.steps) {
                const enabledSensorIds = window._smartFlowSensors
                    .filter(s => s.enabled)
                    .map(s => s.sensor_id);

                // Find and update the capture_sensors step
                const captureStep = generatedSmartFlow.steps.find(s => s.step_type === 'capture_sensors');
                if (captureStep) {
                    captureStep.sensor_ids = enabledSensorIds;
                    captureStep.description = `Capture ${enabledSensorIds.length} sensor(s)`;
                }
            }
        }

        function renderSmartFlowActions() {
            const actionsListDiv = document.getElementById('smartFlowActionsList');
            const actions = window._smartFlowActions || [];

            // Update tab count
            const countEl = document.getElementById('actionsTabCount');
            if (countEl) countEl.textContent = actions.length;

            if (actions.length === 0) {
                actionsListDiv.innerHTML = '<div style="color: #666; font-style: italic; padding: 8px;">No actions found. Record tap/swipe actions in the Flow Wizard to create buttons.</div>';
                return;
            }

            // Sort actions: flow actions first, then stored, then navigation
            const sortedActions = [...actions].sort((a, b) => {
                const order = { 'flow': 0, 'stored': 1, 'navigation': 2 };
                return (order[a.source] || 3) - (order[b.source] || 3);
            });

            actionsListDiv.innerHTML = sortedActions.map((action, i) => {
                const sourceIcon = action.source === 'flow' ? '‚ö° Flow Action' :
                                   action.source === 'stored' ? 'üíæ Saved Action' :
                                   'üß≠ Navigation';
                const sourceColor = action.source === 'flow' ? '#059669' :
                                    action.source === 'stored' ? '#2563eb' :
                                    '#9ca3af';
                return `
                <div class="action-item" style="display: flex; align-items: center; gap: 10px; padding: 8px; border-bottom: 1px solid #cce5ff; ${!action.enabled ? 'opacity: 0.5;' : ''}">
                    <input type="checkbox"
                           id="smartAction_${i}"
                           ${action.enabled ? 'checked' : ''}
                           onchange="toggleSmartFlowAction(${i}, this.checked)"
                           style="width: 18px; height: 18px;">
                    <div style="flex: 1;">
                        <div style="font-weight: 500;">${action.name}</div>
                        <div style="font-size: 0.8em; color: ${sourceColor};">
                            ${action.type} ¬∑ ${sourceIcon}
                        </div>
                        <div style="font-size: 0.75em; color: #999;">${action.description || ''}</div>
                        <div style="font-size: 0.7em; color: #bbb; font-family: monospace;">${action.entity_id}</div>
                    </div>
                </div>
            `}).join('');
        }

        function toggleSmartFlowAction(index, enabled) {
            if (window._smartFlowActions && window._smartFlowActions[index]) {
                window._smartFlowActions[index].enabled = enabled;
            }
        }

        function toggleAllSmartFlowActions(enabled) {
            if (window._smartFlowActions) {
                window._smartFlowActions.forEach(a => a.enabled = enabled);
                renderSmartFlowActions();
            }
        }

        // Tab switching for Smart Flow preview
        function switchSmartFlowTab(tabName) {
            // Hide all tab contents
            document.getElementById('sensorsTabContent').style.display = 'none';
            document.getElementById('suggestedTabContent').style.display = 'none';
            document.getElementById('actionsTabContent').style.display = 'none';

            // Reset all tab buttons
            document.getElementById('tabSensors').style.borderBottom = 'none';
            document.getElementById('tabSensors').style.background = '#fff';
            document.getElementById('tabSuggested').style.borderBottom = 'none';
            document.getElementById('tabSuggested').style.background = '#fff';
            document.getElementById('tabActions').style.borderBottom = 'none';
            document.getElementById('tabActions').style.background = '#fff';

            // Activate selected tab
            const tabColors = {
                sensors: { bg: '#f8f9fa', border: '#2196F3' },
                suggested: { bg: '#fff8e5', border: '#ffc107' },
                actions: { bg: '#e8f4fd', border: '#1976D2' }
            };

            const tab = tabColors[tabName];
            document.getElementById(`${tabName}TabContent`).style.display = 'block';
            document.getElementById(`tab${tabName.charAt(0).toUpperCase() + tabName.slice(1)}`).style.borderBottom = `2px solid ${tab.border}`;
            document.getElementById(`tab${tabName.charAt(0).toUpperCase() + tabName.slice(1)}`).style.background = tab.bg;
        }

        // Render suggested (smart-detected) sensors
        function renderSuggestedSensors() {
            const listDiv = document.getElementById('suggestedSensorsList');
            const suggestions = window._suggestedSensors || [];

            // Update tab count
            const countEl = document.getElementById('suggestedTabCount');
            if (countEl) countEl.textContent = suggestions.length;

            // Show/hide the tab if no suggestions
            const tabBtn = document.getElementById('tabSuggested');
            if (tabBtn) {
                tabBtn.style.display = suggestions.length > 0 ? 'block' : 'none';
            }

            if (suggestions.length === 0) {
                listDiv.innerHTML = '<div style="color: #856404; font-style: italic; padding: 8px;">No new sensors detected on current screen. Navigate to screens with data elements to see suggestions.</div>';
                return;
            }

            listDiv.innerHTML = suggestions.map((s, i) => `
                <div class="sensor-item" style="display: flex; align-items: center; gap: 10px; padding: 8px; border-bottom: 1px solid #f0e6c8; ${!s.enabled ? 'opacity: 0.6;' : ''}">
                    <input type="checkbox"
                           id="suggestedSensor_${i}"
                           ${s.enabled ? 'checked' : ''}
                           onchange="toggleSuggestedSensor(${i}, this.checked)"
                           style="width: 18px; height: 18px;">
                    <div style="flex: 1;">
                        <div style="font-weight: 500;">${s.name}</div>
                        <div style="font-size: 0.8em; color: #856404;">
                            ${s.device_class || 'generic'}${s.unit ? ' ¬∑ ' + s.unit : ''} ¬∑ ${Math.round((s.confidence || 0.5) * 100)}% match
                        </div>
                        <div style="font-size: 0.75em; color: #666;">
                            Value: <strong>${s.element_text || '(empty)'}</strong>
                        </div>
                        <div style="font-size: 0.7em; color: #999;">${s.reason || ''}</div>
                        <div style="font-size: 0.7em; color: #bbb; font-family: monospace;">${s.suggested_entity_id || ''}</div>
                    </div>
                </div>
            `).join('');
        }

        function toggleSuggestedSensor(index, enabled) {
            if (window._suggestedSensors && window._suggestedSensors[index]) {
                window._suggestedSensors[index].enabled = enabled;
            }
        }

        function toggleAllSuggestedSensors(enabled) {
            if (window._suggestedSensors) {
                window._suggestedSensors.forEach(s => s.enabled = enabled);
                renderSuggestedSensors();
            }
        }

        function renderSmartFlowSteps(showAll) {
            const stepsDiv = document.getElementById('smartFlowSteps');
            const btn = document.getElementById('btnExpandSteps');
            const allSteps = window._smartFlowAllSteps || [];

            const steps = showAll ? allSteps : allSteps.slice(0, 10);
            stepsDiv.innerHTML = steps.map((step, i) => `
                <div class="preview-step">
                    <span class="step-num">${i + 1}</span>
                    <span class="step-type">${step.step_type}</span>
                    <span class="step-desc">${step.description || ''}</span>
                </div>
            `).join('');

            if (!showAll && allSteps.length > 10) {
                stepsDiv.innerHTML += `<div class="preview-step more" style="color: #666; font-style: italic;">... and ${allSteps.length - 10} more steps</div>`;
            }

            btn.textContent = showAll ? 'Show Less' : `Show All (${allSteps.length})`;
            stepsDiv.style.maxHeight = showAll ? '400px' : '200px';
        }

        function toggleSmartFlowSteps() {
            smartFlowStepsExpanded = !smartFlowStepsExpanded;
            renderSmartFlowSteps(smartFlowStepsExpanded);
        }

        async function testSmartFlow() {
            if (!generatedSmartFlow) {
                showToast('No flow to test', 'warning');
                return;
            }

            const testBtn = document.getElementById('btnTestSmartFlow');
            const saveBtn = document.getElementById('btnSaveSmartFlow');
            testBtn.disabled = true;
            saveBtn.disabled = true;
            testBtn.textContent = 'üß™ Testing...';

            // Show loading overlay
            const loadingOverlay = document.createElement('div');
            loadingOverlay.id = 'testFlowLoadingOverlay';
            loadingOverlay.innerHTML = `
                <div style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center; z-index: 10000;">
                    <div style="background: white; padding: 30px 50px; border-radius: 12px; text-align: center; max-width: 400px;">
                        <div style="font-size: 48px; margin-bottom: 16px;">üß™</div>
                        <h3 style="margin: 0 0 12px 0; color: #333;">Testing Flow</h3>
                        <p id="testFlowStatus" style="color: #666; margin: 0 0 16px 0;">Preparing test...</p>
                        <div style="width: 100%; height: 4px; background: #e0e0e0; border-radius: 2px; overflow: hidden;">
                            <div id="testFlowProgress" style="width: 10%; height: 100%; background: #2196F3; transition: width 0.3s;"></div>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(loadingOverlay);

            const updateStatus = (msg, progress) => {
                const statusEl = document.getElementById('testFlowStatus');
                const progressEl = document.getElementById('testFlowProgress');
                if (statusEl) statusEl.textContent = msg;
                if (progressEl) progressEl.style.width = progress + '%';
            };

            let savedFlowId = null;
            let savedDeviceId = null;

            try {
                // Step 1: Save the flow temporarily (disabled by default)
                updateStatus('Saving flow for test...', 20);
                const flowToSave = {
                    ...generatedSmartFlow,
                    enabled: false,
                    name: generatedSmartFlow.name + ' (Test)'
                };

                const saveResponse = await fetch(`${window.flowManager.apiBase}/flows/generate-smart/save`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(flowToSave)
                });

                const saveResult = await saveResponse.json();
                if (!saveResult.success) {
                    throw new Error(saveResult.message || 'Failed to save flow for testing');
                }

                savedFlowId = saveResult.flow.flow_id;
                savedDeviceId = saveResult.flow.device_id;

                // Check if Learn Mode is enabled
                const learnMode = document.getElementById('smartFlowLearnMode')?.checked || false;
                const execMessage = learnMode
                    ? 'Executing flow with learning (slower)...'
                    : 'Executing flow on device...';
                updateStatus(execMessage, 40);

                // Step 2: Execute the flow (with learn_mode if enabled)
                const execUrl = new URL(`${window.flowManager.apiBase}/flows/${savedDeviceId}/${savedFlowId}/execute`, window.location.origin);
                if (learnMode) {
                    execUrl.searchParams.set('learn_mode', 'true');
                }

                const execResponse = await fetch(execUrl.toString(), {
                    method: 'POST'
                });

                updateStatus('Processing results...', 80);

                if (!execResponse.ok) {
                    const error = await execResponse.json();
                    throw new Error(error.detail || 'Flow execution failed');
                }

                const execResult = await execResponse.json();
                console.log('[SmartFlow] Test result:', execResult);
                console.log('[SmartFlow] Step results:', execResult.step_results);
                console.log('[SmartFlow] Captured sensors:', execResult.captured_sensors);

                // Log learned screens if Learn Mode was used
                if (learnMode && execResult.learned_screens) {
                    console.log('[SmartFlow] Learned screens:', execResult.learned_screens);
                }

                updateStatus('Complete!', 100);

                // Remove loading overlay before showing results
                const overlay = document.getElementById('testFlowLoadingOverlay');
                if (overlay) overlay.remove();

                // Step 3: Show execution results (pass the flow definition for step details)
                showExecutionResults(execResult, generatedSmartFlow);

                if (execResult.success) {
                    showToast('Flow test passed! You can now save the flow.', 'success');
                } else {
                    showToast('Flow test failed: ' + (execResult.error_message || 'Unknown error'), 'error');
                }

            } catch (error) {
                console.error('Failed to test smart flow:', error);
                showToast('Test failed: ' + error.message, 'error');
            } finally {
                // Remove loading overlay if still present
                const overlay = document.getElementById('testFlowLoadingOverlay');
                if (overlay) overlay.remove();

                // Clean up: Delete the test flow
                if (savedFlowId && savedDeviceId) {
                    try {
                        await fetch(`${window.flowManager.apiBase}/flows/${savedDeviceId}/${savedFlowId}`, {
                            method: 'DELETE'
                        });
                        console.log('[SmartFlow] Cleaned up test flow');
                    } catch (cleanupError) {
                        console.warn('[SmartFlow] Failed to cleanup test flow:', cleanupError);
                    }
                }

                testBtn.disabled = false;
                saveBtn.disabled = false;
                testBtn.textContent = 'üß™ Test Flow';
            }
        }

        async function saveSmartFlow() {
            if (!generatedSmartFlow) {
                showToast('No flow to save', 'warning');
                return;
            }

            const saveBtn = document.getElementById('btnSaveSmartFlow');
            saveBtn.disabled = true;
            saveBtn.textContent = 'Saving...';

            try {
                // Get selected suggested sensors to create
                const selectedSuggestions = (window._suggestedSensors || []).filter(s => s.enabled);
                const sensorsCreated = [];

                // Create selected suggested sensors first
                if (selectedSuggestions.length > 0) {
                    saveBtn.textContent = `Creating ${selectedSuggestions.length} sensors...`;

                    for (const suggestion of selectedSuggestions) {
                        try {
                            const sensorData = {
                                device_id: generatedSmartFlow.device_id,
                                friendly_name: suggestion.name,
                                entity_id: suggestion.suggested_entity_id,
                                element_index: suggestion.element_index,
                                element_bounds: suggestion.bounds,
                                device_class: suggestion.device_class || 'none',
                                unit_of_measurement: suggestion.unit || '',
                                enabled: true,
                                update_interval_seconds: 60
                            };

                            const createResp = await fetch(`${window.flowManager.apiBase}/sensors`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify(sensorData)
                            });

                            const createResult = await createResp.json();
                            if (createResult.success || createResult.sensor_id) {
                                sensorsCreated.push(createResult.sensor_id || suggestion.suggested_entity_id);
                                console.log(`Created sensor: ${suggestion.name}`);
                            }
                        } catch (sensorError) {
                            console.warn(`Failed to create sensor ${suggestion.name}:`, sensorError);
                        }
                    }

                    // Add newly created sensors to the flow's capture step
                    if (sensorsCreated.length > 0) {
                        const captureStep = generatedSmartFlow.steps.find(s => s.step_type === 'capture_sensors');
                        if (captureStep) {
                            captureStep.sensor_ids = [...(captureStep.sensor_ids || []), ...sensorsCreated];
                            captureStep.description = `Capture ${captureStep.sensor_ids.length} sensor(s)`;
                        }
                    }
                }

                saveBtn.textContent = 'Saving flow...';

                const response = await fetch(`${window.flowManager.apiBase}/flows/generate-smart/save`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(generatedSmartFlow)
                });

                const result = await response.json();

                if (!result.success) {
                    throw new Error(result.message || 'Save failed');
                }

                const msg = sensorsCreated.length > 0
                    ? `${result.message} (created ${sensorsCreated.length} new sensors)`
                    : result.message;
                showToast(msg, 'success');
                closeSmartFlowModal();
                await loadFlows();

            } catch (error) {
                console.error('Failed to save smart flow:', error);
                showToast('Save failed: ' + error.message, 'error');
            } finally {
                saveBtn.disabled = false;
                saveBtn.textContent = 'Save Flow';
            }
        }

        function closeSmartFlowModal() {
            document.getElementById('smartFlowModal').style.display = 'none';
            generatedSmartFlow = null;
        }

        // Make smart flow functions globally available
        window.showSmartFlowModal = showSmartFlowModal;
        window.closeSmartFlowModal = closeSmartFlowModal;
        window.onSmartFlowDeviceChange = onSmartFlowDeviceChange;
        window.onSmartFlowAppChange = onSmartFlowAppChange;
        window.onDiscoveryModeChange = onDiscoveryModeChange;
        window.generateSmartFlow = generateSmartFlow;
        window.testSmartFlow = testSmartFlow;
        window.saveSmartFlow = saveSmartFlow;
        window.toggleSmartFlowSteps = toggleSmartFlowSteps;
        window.toggleSmartFlowSensor = toggleSmartFlowSensor;
        window.toggleAllSmartFlowSensors = toggleAllSmartFlowSensors;
        window.toggleSmartFlowAction = toggleSmartFlowAction;
        window.toggleAllSmartFlowActions = toggleAllSmartFlowActions;
        window.switchSmartFlowTab = switchSmartFlowTab;
        window.toggleSuggestedSensor = toggleSuggestedSensor;
        window.toggleAllSuggestedSensors = toggleAllSuggestedSensors;

        // Load flows on page load
        async function initPage() {
            await loadDeviceIdentities();
            await loadFlows();
        }

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initPage);
        } else {
            initPage();
        }

        // Keyboard shortcut for refresh (Ctrl+R / Cmd+R)
        document.addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 'r') {
                e.preventDefault();
                showToast('Refreshing...', 'info');
                loadFlows();
            }
        });

        // ==========================================================================
        // Auto-Refresh / Live Status
        // ==========================================================================
        let autoRefreshInterval = null;
        const AUTO_REFRESH_INTERVAL_MS = 10000; // 10 seconds

        function setupAutoRefresh() {
            const toggle = document.getElementById('autoRefreshToggle');
            if (!toggle) return;

            // Load preference from localStorage
            const savedPref = localStorage.getItem('flows.autoRefresh');
            toggle.checked = savedPref !== 'false'; // Default to true

            // Start auto-refresh if enabled
            if (toggle.checked) {
                startAutoRefresh();
            }

            // Handle toggle change
            toggle.addEventListener('change', () => {
                localStorage.setItem('flows.autoRefresh', toggle.checked);
                if (toggle.checked) {
                    startAutoRefresh();
                } else {
                    stopAutoRefresh();
                }
            });
        }

        function startAutoRefresh() {
            if (autoRefreshInterval) return; // Already running

            console.log('[Flows] Starting auto-refresh (every 10s)');
            autoRefreshInterval = setInterval(async () => {
                try {
                    // Only update scheduler status and flow execution times (lightweight)
                    await loadSchedulerStatus();
                    await updateFlowExecutionTimes();
                } catch (e) {
                    console.warn('[Flows] Auto-refresh failed:', e);
                }
            }, AUTO_REFRESH_INTERVAL_MS);
        }

        function stopAutoRefresh() {
            if (autoRefreshInterval) {
                console.log('[Flows] Stopping auto-refresh');
                clearInterval(autoRefreshInterval);
                autoRefreshInterval = null;
            }
        }

        /**
         * Lightweight update of flow execution times without full reload
         */
        async function updateFlowExecutionTimes() {
            try {
                // Fetch all flows to get updated execution info
                const response = await fetch(`${window.flowManager.apiBase}/flows`);
                if (!response.ok) return;

                const data = await response.json();
                const flowList = data.flows || data || [];

                // Update each flow card's execution time
                for (const flow of flowList) {
                    const flowId = flow.flow_id;

                    // Update last executed time
                    const lastExecEl = document.querySelector(`[data-flow-id="${flowId}"] .last-executed, [data-flow-id="${flowId}"] .flow-meta .meta-item:nth-child(2)`);
                    if (lastExecEl && flow.last_executed) {
                        const timeAgo = formatTimeAgo(flow.last_executed);
                        if (lastExecEl.textContent !== timeAgo) {
                            lastExecEl.innerHTML = `<span class="meta-label">Last Run:</span> ${timeAgo}`;
                        }
                    }

                    // Update execution count
                    const execCountEl = document.querySelector(`[data-flow-id="${flowId}"] .execution-count`);
                    if (execCountEl) {
                        const newCount = `${flow.execution_count || 0} runs`;
                        if (!execCountEl.textContent.includes(flow.execution_count)) {
                            execCountEl.textContent = newCount;
                        }
                    }
                }
            } catch (e) {
                // Silently fail - this is just a background update
            }
        }

        // Stop auto-refresh when page is hidden, restart when visible
        document.addEventListener('visibilitychange', () => {
            const toggle = document.getElementById('autoRefreshToggle');
            if (document.visibilityState === 'hidden') {
                stopAutoRefresh();
            } else if (toggle?.checked) {
                startAutoRefresh();
            }
        });

        // Initialize auto-refresh after page load
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', setupAutoRefresh);
        } else {
            setupAutoRefresh();
        }
    </script>
</body>
</html>
